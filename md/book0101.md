## Chapter 1 前奏

不管三七二十一，直接讲授如何通过各种所谓考试的方法十分有害，乃是导致许多人缺乏真正上机实践能力的核心所在。因此本章在具体讲授某种语言之前力图先解决这样的疑惑：当面临一个给定的或简单或复杂或接近现实或已经有一定抽象的问题，如何开始着手思考这个问题，如何把它们一步步转化为可以最终编程解决（甚至在纸笔乃至口头上解决）的问题？

如果不能在这个意义上解决问题，我们的编程语言学习就是白费功夫。因此我们首先要解释一些基本的 ***算法(algorithm)*** 概念。

随后，我们将给出具体的学习的初步建议，并给出一些如何在自己的计算机上配置编程环境的指导。

### Section 1-1 算法概念

一个比较经典的描述大致如下。^\[1]

要用计算机解决一个较为复杂的实际问题，一般要经历如下四个步骤：

1. 分析问题：特别是尽可能地把问题数学化、形式化，也就是建立一个数学模型。（建模？）
2. 根据分析，并利用分析后确立的数学模型，设计其求解步骤。（即 **算法设计** ）
3. 用某种形式来表达已经设计好的算法，比如使用图形表达、自然语言描述或者 **伪代码** 等形式。
4. 用一种计算机语言实现算法，并在计算机上编辑、调试和测试编制好的程序，直到正确满足问题的要求。

由此可见，要想解决一个实际问题，编程语言并不是最关键的那部分，它最大的影响在于限制你选择的具体步骤必须是能够被编程实现的（而不是臆造某种“神奇步骤”）。但是，总体上的解决方案，其关键绝不在于如何具体地写出每一行的代码，而是在前三步的准备工作中解决。第一步是解决模型的数据结构，第二步是解决问题的算法，第三步是形式化地描述算法，而最后一步——准备皆已完成，则代码等等应当成竹在胸，行云流水，剩下的不过是现实手段的制约罢了。

所谓“算法”，就是一组有穷的规则，它们规定了解决某一特定类型问题的一系列运算。通俗地讲，是指完成某一项任务的方法和步骤，对程序设计而言是对解题过程的准确而完整的描述，既可以是数学公式也可以是规则，总之最终必须表示为上机操作运行的命令。从计算机系统的角度，算法也可以理解为：程序（数据处理）+数据结构（数据组织）。^\[2]

算法的基本性质：

1. 有限性——运算项有限，且均在有限时间内；（即使总的时间可能是不可接受的超大数字）
2. 确定性——每一项运算有明确定义，无二义性（歧义）；
3. 输入输出——有时也允许没有输入（算法本身的起始状态固定），但是必须有输出项；
4. 可行性——又称“正确性”，必须对所有给定的合法输入有对应的正确输出。


### Section 1-2 描述算法

必须要把算法准确地描述出来，才能开始将其实现和转化。

#### 1-2-1 自然语言描述

考虑一个简单的例子——求数字a，b，c当中的最大值。

也许你会觉得而是一个过分简单的问题，不过，因为我们过分熟悉简单问题，这会产生一点“遮蔽作用”，在我们开始学习时产生一点障碍。

```
赋给A, B, C 初值
将 A 的值 给 MAX
比较 B>MAX， 倘若条件成立， 把B的值给MAX
比较 C>MAX， 倘若条件成立， 把C的值给MAX
输出MAX
```

现在来看一个复杂的例子——判断一个正整数N是否为素数。你肯定在做一些无聊的心理测试小问卷中看到过相似的做法。

```
1. 设除数为I，赋其初值为2
2. 用I除N，得到余数R
3. 如果R=0，表示I整除N，N不是素数，输出指示，算法结束；否则继续下一步
4. 使I的加上1
5. 如果I<N，返回第2步继续；否则输出N是素数的指示，算法结束。
```
自然语言某种程度上可以很好地描述算法，并且你也看到，这本身也相当自然（想想你被那些心理小测试之类的东西玩得乐此不疲的时候）。不过，这么做有一些固有的缺陷。

+ 繁琐冗长——使用自然语言文字描述相比符号形式系统文字量很大，书写与检验都不便利。
+ 不规范性——同一种意思可以有几乎无数种表达，包括容易理解和不容易理解的。
+ 二义性——自然语言是约定俗成的语言，容易出现一句话产生歧义的可能。

实际运用中自然语言主要作用是进行口头概括。一段复杂的算法过程如果是有前人章法可循的，则经常有一个概括性的称呼来表达其运算过程。

#### 1-2-2 图形描述

应该可以做这样的假设，此刻，基本上所有的读者都至少对一种被称为"流程图"的东西有所了解。

![流程图示例1][pic_121_01]
 
上面是一个简单的流程图的例子。顾名思义，它可以描述算法的基本流程，能够形象直观，降低歧义，增强理解。

流程图有助于把我们从自然语言的流水账中不明确的信息明确出来，清晰地描述开始，进行，转折，结束的具体情形。

上面的这张图距离把语言形式化还有距离，实际上还和自然语言描述靠得很近。

> 现在起你也应当纠正一种不合适的想法：计算机编程是为了让计算机能听懂我们而做的妥协。不尽然如此。事实上，更有必要的是，我们有必要审视我们一般的日常语言描述存在的缺陷，正视它们不能有效率地给出确定的指令的现实。如果在学习的过程中不断地感到难以理解各种做法的缘由，那么就有必要审视，你有没有采取正确的思维方式。

考虑到自然语言存在的随意性和多义性，有必要采取规范化、抽象化、形式化的方法。可以看下面一个数学化的流程图示范。

![流程图示例2][pic_121_02]
 
在这样的典型的流程图中，形式化的语言取代了自然语言。通过使用数学上的一些变量，并运用"赋值""比较"等操作，我们能完成一些基本的功能。如果你对数学上的"映射"概念有一定的理解，相信你也能清楚，这种方法看起来抽象，却足以完成我们需要的逻辑。
 
流程图的语言再作进一步抽象就是原始的高级语言的形式了。

在计算机编程语言的发展历程中，又对图形直观表述算法的方法有一些反哺性的改良。（这会之后提到）

#### 1-2-3 程序设计语言

计算机中的语言分为低级语言和高级语言。低级语言包括机器语言的汇编语言。

原始的计算机程序设计是完全面向硬件的。基于数字电路给出的抽象，我们得以用一定的简单的规则通过某种方式向计算机输入信息。在相当一段时间内，一个成熟的方法是使用卡带。通过在穿孔纸带或卡片上有规律地打孔，就可以把二进制信息输入到计算机内。原始的程序编写现实中就是进行“打孔”的工作。这个时候我们只有被称为"机器码"的编码可以使用——你必须手动打出每一个0和1来。

汇编语言是一种符号性语言，本质上是用易记的英文单词缩写来代替难以记忆的机器码。因此是一种“助记符”。汇编语言不能直接运行，需要先将其翻译为机器码。但是因为本质上是和机器码完全一一对应的，因此汇编语言仍然运行很快——同时这也意味着汇编语言是和机器绑定的，依赖机器，不同的计算机可能有无法通用的不同的汇编语言。（不过，现时主流的处理器(CPU)之间有一定的兼容性）

高级语言的出现从根本上解决了问题，它们的语言特性与机器无关，并且还与人的自然语言表达方式更加接近。高级语言的代码必须经过一定的"翻译"流程才能生成真正为计算机所能理解的可执行代码。

编程语言在这一路径上大致可分为两类，即编译型和解释型，如今这两者界限并不明显。

编译型语言在早期占据主流地位，通过被称为 **编译(compile)** 的流程， **源代码(source coding)** 经过一系列处理后（通常会有汇编语言作为中介之一）被翻译为机器语言的代码，随后运行时只需要运行生成的 **可执行文件(executable file)** 就能运行程序，这个过程保障了最大化的效率。执行编译过程的程序被称为 **编译器(compiler)** 。典型的编译型语言包括PASCAL/C/C++。

解释型语言通常依靠一个专门的解释器来进行工作，在执行代码时才对程序进行翻译工作。起初这是方便初学者的考虑。在计算机性能大大提高的今天，解释型语言（如今更流行的一种说法称为脚本语言）凭借极大的便利性赢得广泛的受众。不必编译的特点能够极大的方便程序员测试自己的代码。典型的解释型语言包括Python/PHP等等。

编译与翻译的区别并非一道深堑，更多是一种根据需要的选择。如今不少语言同时支持两者，赋予开发者更大的自由；此外还有不少语言选择一种中间方案，首先把代码翻译成一种中间格式，然后由专门的程序来执行这些中间代码，这些语言是基于虚拟机的语言，典型代表为Java。

#### 1-2-4 伪代码

直接使用代码来描述算法在思考阶段可是过于奢侈了一些，但我们又需要详尽的描述算法而不是等到开始用代码实现时需要完全转标表达方式。为了节省一些细节，我们通常会使用伪代码来作为一个过渡的对算法的详细描述。

使用伪代码的目的是使被描述的算法可以容易地以任何一种编程语言实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言，介于自然语言与编程语言之间。以编程语言的书写形式指明算法职能，不用拘泥于具体实现。伪代码的写法没有一个既定的标准，只需要遵循一些既定的规约，核心在于简约到位地表示清楚算法流程。

基于读者的实际情况和需求，本书在大部分内容讲述中不采用伪代码形式。
 
### Section 1-3 算法实现

以一个具体的问题为例，我们来展示一下如何针对这个问题进行编程上的解决。

###### 问题：在最多 500 X 500 的方格纸（每个格子都是边长为1的正方形）上给出两个整点A(x1, x2), B(x2, y2)。在A和B之间连一条线段，试问该线段经过几个格子顶点（即横纵坐标都是整数）？（设定坐标取值在0<=x,y<=500之间。）

试着先自己思考一下如何设计一个通用的解法，使得能够对任意给定的条件算出结果？

如果一下子进入程序设计思维有点困难，可以先考虑一下作为一道数学（竞赛？）题你可以怎样去做它。

> 解：
>
> 第一步，分析。
> 
> 尝试一下转化这个问题？（你可试一试在纸上画几个例子）
> 
> 不妨取x=|x2-x1|, y=|y2-y1|. 显然我们有结论，答案只和所得差值x与y有关，从而首先简化了输入信息。
> 
> 现在我们来考虑一下这个线段穿过格子的情形。
> 
> 不需要很严格的推导，我们不难有一个结论，线段穿过的整点在这条线段上是均匀分布的，不存在有疏有密的可能。我们可以把这些整点作为分割点，如果有n个分割点就能把线段分成n+1段，显然，我们可以知道，这n+1段分割出来的线段完全一样。
> 
> 现在，我们考虑一个新的问题——什么情形下，从原点引一线段到另一整点，中间不经过其他整点？
> 
> 我们考虑一个原点O(0, 0)，和另一个点A1(x, y)，它们中间连线没有整点。
>
> 现在我们可以延伸这条线，于是显然还存在A2(2x, 2y), A3(3x, 3y), ... 。显然，它们与原点相连，其间有1, 2, ... 个整点
>
> 于是我们可以反过来考虑，任何一个点都可以规约到这个序列中。
>
> 我们得到如下定理：若OA间有n个交点，则A坐标为((n+1)x, (n+1)y)（其中(x,y)从原点到该点间无其他整点）。这个形式似乎还缺点什么。
> 
> 拓展定理：不妨设OA间有n-1个点，其中A(x, y)。<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 则必有OB(kx, ky)间有kn-1个整点。（k是正整数）
>
> 注意到，k显然既是kx的因数又是ky的因数。
>
> 现在对给定的B(x^' , y^' )，求它们的最大公因数k使得x^' = kx, y^' = ky。这时x和y是互质的，它们的最大公因数等于1，根据上面的结论，没有办法作一个序列使得(x, y)和O(0, 0)之间还有其他点。
>
> 由此，我们得到证明，令x=|x2-x1|, y=|y2-y1|, 则经过整点数 = gcd(x, y)-1.（gcd是求最大公因数符号）
>
> 事实上，如果具备一些数学上的直觉，可以在举例子尝试时比较迅速地归纳出一定的规律性，不过欲证明求最大公因数这个思路正确，大体如此。
>
> 第二步：求解步骤
> 
> 欲要求解两个正整数的最大公因数，古人已经在典籍《九章算术》中完整阐述了其做法—— **辗转相除法（又称 *欧几里得算法(Euclidean algorithm)* ）**
>
> 第三步：辗转相除法的描述
>
> 用两数中较大一数除以较小一数，得到一个余数，再用除数除以得到的余数继续这一过程，循环往复，直到余数为0，则此时除数为结果。
>
> 换用规范化的说法套用本题语境:
>
> 1. 输入x1, y1, x2, y2;
> 2. 赋值，令x=|x2-x1|, y=|y2-y1|;
> 3. 赋值 r 为 x 除以 y 的余数;
> 4. 判断 r=0, 如果条件成立，继续下一步；否则把y赋值给x，r赋值给y，回到步骤3;
> 5. 输出 y-1，这就是答案。
>

不难发现这是我们已经基本解决了问题，如果此时已经基本掌握了一种以上编程语言，具体代码难道还不能呼之欲出吗？

 
### Section 1-4 环境选择

#### 1-3-1 语言流派

编程语言的派系实际上非常繁多，包含了各种并不相同的思想流派。从哪一种编程语言开始学习，从什么侧重点开始切入，实际上应当是非常审慎的行为。

不幸的是，许多人就是从这个时候开始无法进行学习的。所以这一节我们有必要讨论一下这个重中之重的话题。

通常的取舍在Pascal、C/C++、Python、Java等几种语言中间。

>
+ PASCAL语言是第一个达成了整饬的形式的高级语言，在当时的时代独树一帜。不幸的是，当时的作者对其的开发期待是使其成为一种教学语言。毫无疑问，这门严谨规范的语言的教学作用不可低估，但是由于极其严格的规范要求对编程者的自由有着不少限制，后来这一语言逐渐脱离潮流。
+ C语言功能空前强大，设计之初就是为编写操作系统而生。C语言假设程序员明确自己的行为并充分信任他们进行自由的操作，与此同时C语言又高度贴近汇编的语言结构，同时C语言也是第一个充分考虑如何建立大型软件系统的语言。C语言一直是强大的基石语言。
+ C++设计之初是为了拓展C语言。在随后的岁月里，它不断地吸收各方面的新的编程思想（虽然这也常常是为人所诟病的一面），更加适用于复杂的软件工程，影响深远。
+ Python是一种脚本语言，致力于为让使用者把精力集中于解决问题而不是语言内容。Python的一个格言是"用一种方法，最好是只有一种方法来做一件事"。
+ Java是面向对象的语言，开创了虚拟机类语言的先河，具有极强的跨平台支持能力，规范严格，广泛应用于大规模软件工程开发。

+ 作为良好编程习惯的开端，Pascal实际上具有不容忽视的作用。不过由于近些年来的衰落，大规模基于其进行教学已经基本没有现实基础了。但是，不容忽视的是，Pascal曾一度为相当流行的语言，有不容忽视的地位，许多遗留的文档和规范源自PASCAL。本书虽然不会重点介绍该语言，但是会尝试改变一贯的回避作风。
+ C/C++是功能强大的语言，但是错误的学习往往要把学习者引往不归路。C的哲学是程序员同时具有极大的自由，也对自己的自由负责。如果达成真正的理解，你能够以这一媒介获得极深刻的认识，获得触类旁通的秘诀；如果不能有一定理解，恐怕这个语言多半是先给人带来痛苦。
+ Python进一步隔离程序员与计算机内部细节的联系。对于非专业人员，或者进行研究者，以及希望快捷开发自己所需功能者，这一语言十分适合。
+ Java恐怕是这之中最不适合初学的语言。Java以组织大型软件工程见长，以繁冗的规范进行协调，用虚拟机隔离计算机模型，从多个角度看从Java开始基础性的学习没有什么优点（除非你打算只学习Java）。

本书根据现今的教学实际，以C++语言的使用作为主要内容，同时也会兼顾PASCAL和C乃至现代语言的做法，力求开拓广阔的视野。

#### 1-3-2 环境搭建

有一种不负责任的说法试图灌输这样一种错误的观念：优秀的程序员可以只用记事本（windows下的notepad）编程。这是一个极其扭曲的认识。记事本最多做一些最简单的工作，它不支持绝大部分的高级编辑功能，更不支持编译，只能用于最简单的程序编写，想要进行复杂的工作恐怕会令人十分痛苦。

学习编程，首先你必须有可以随时可以进行代码编写与测试的机器。某种程度上这不是完全必备的条件，但这要求你的学习更加严谨细致。

随时记住，你最好的合作伙伴，除了当前的这本书以及其他手上的入门书籍，还有如下的一些知识来源：google.com, baidu.com, cn.bing.com, CSDN, etc.. --拥抱新时代的学习方法吧。

+ 一个比windows下的notepad更合适编程的软件是nodepad++，这个软件是一个精巧的升级版记事本，支持辨识代码格式、语法高亮、代码自动补全等功能，并且能够拓展更多自定义的插件。比起notepad最重要的改进是，notepad++支持无·次数限制的撤销/恢复功能--以避免你的代码过于容易地被破坏，notepad++也支持更强大的在文档中进行查找/替换的功能。然而，notepad++的缺点是，比起其他一些更专业化的的工具，它还是显得简陋。

+ Sublime Text是更加专业性的工具，它们支持更高级的代码组织功能，甚至是加入编译插件。事实上你现在就可以尝试用它们做一些简单的工作，不过想要配置好它们有些繁琐，初学时在这些上面花时间有些偏离重点了，这是我们学习一定深度后更适合考虑的内容。

+ Dev-C++是一个传统的信息学竞赛中使用的C++IDE，但是其多方面功能的孱弱使其难堪大用，初学者可以很快用它构建自己的前几个程序，随后我们不建议使用它。需要指出的是它采用GNU C++系列编译器。这是C++语言的一个与其他几乎所有语言都不相同的独特之处--由于C++堪称最复杂的语言，有多家不同的公司和组织都在开发自己的C++产品，C++是一个只有"标准"的语言，而几乎所有编译器都不能（或者不打算）支持全部已制定的的C++标准。不同系列甚至不同版本的C++编译器对C++代码有不同的处理方法。GNU是一系列开源编译器的总称，"开源"意味着编译程序的代码是公开的，这使得GNU C++（常常又简写为G++）成为众多领域的重要标准。

+ CodeBlocks是一个轻量级的IDE，在不大的空间内集成了大量实用的功能，是大学生程序设计竞赛的标准环境之一。想要使用CodeBlocks学习C++，最好选择下载自带GNU C++编译器的版本，避免一开始就陷入配置的麻烦。

+ Microsoft Visual Studio 是功能强大的windows下集成开发环境。初学C++可以相当方便地从此入门。目前推荐安装不低于VS2010的版本。其缺点是占用很大空间，安装配置需要腾出不短的时间，启动速度相对较慢。其C++编译器是微软开发的MSVC（Microsoft Visual C++）。

> 必须针对提出警告的是一款上古IDE：VC6.0。这一编译器目前还在各大高校的各个不密切相关专业中被广泛应用。除去所谓的计算机二级考试这个理由，在当下看来VC6.0的缺陷可谓罄竹难书。当然，考虑到还有人不得不使用它（此处应该表示默哀），我们会适当辨析一些VC6.0独有的问题。

本书并不打算像一些已经比较过时的书籍那样，规定一个标准的参考编译器，不对读者使用不同版本的编译器产生的问题负责--这同样是不合理的。有另一种时常存在的误区（不太清楚其产生来源），有人认为，想要研究一些搞不清的编程问题，只要敲出对应的一些代码进行编译，查看程序运行情况或者翻译出来的汇编代码就可以把情况搞清楚。这种做法某种程度上可以帮助你确定存在一种问题，但是，如果认为用这样的方法就一定能理解问题的原因与原理，则往往是流于表面的，对于C++语言尤其是如此。编译器如何对一段代码进行翻译，通常是遵循一定的标准，而一段对标准有偏差理解而写出来的代码存在的问题经常是隐晦的。有时，由于代码编写的不好，会导致有随机性甚至多义性不确定性；由于编译器的不完善，随着版本更新，原本就糟糕的代码很可能表现出不同的结果。现代的编译器在打开优化开关之后都能够智能地优化生成的代码，如果编写看似没有问题的代码（实则并不规范），可能遭到编译器错误的处理，而版本迭代又容易导致细微之处的不同。想要搞清楚根本性的问题，无论如何还是要了解语言本身规定的标准、编译器实现的标准、以及什么样的做法规范什么样的做法并非规范。

相反，本书的讲解将以跨平台为一个基本点。可以假设，在这里我们只写各种主流编译器上都能很好运行的程序（好吧，VC6.0可能并不一定能符合，如果它还算做某种形式的主流的话）。读者也可以尝试不拘泥于单独的一种环境完成学习——不要依赖于某种特定的环境，让自己能够灵活变通是非常重要的。

#### 1-3-3 Hello, world!

以Visual Studio 2015为例，我们来具体做一个开始编程的指引。

> 根据此前经历过的一些奇葩遭遇，我想，还是有必要指出，开始一切工作前，我们最好先确认，您已经把系统调整到一个看起来稍微专业点的程度--比如说，您已经在"设置"（或者"控制面板"）中设置好不隐藏所有文件的拓展名。文件的拓展名实际上只是windows为了方便标识应当自动地采用那一种程序来打开某一类文件，但是同时这也意味着导致一些文件名实际不同的文件看起来相同。您应当让系统支持您自行修改文件名后缀，这会让工作更加便利。
>
> 如果甚至不清楚如何设置，我们建议您自行搜索相关的内容或询问身边的人。这里的篇幅恐怕不太够用了了。

如果你正确地依照安装程序的指示安装好了带有Visual C++2015组件的VS2015，并完成了诸如激活等麻烦事以后，你就可以进入一个开始界面，准备好开始写第一个C++程序了。

鉴于您可能是第一次进入这个界面，我们来做一点详细的介绍。

![截屏1][pic_133_01]
 
开始第一个程序的编写，您需要点击"文件-新建-项目"，在接下来显示的这个对话框中，选择"模板-Visual C++-常规"中的"空项目"。

值得指出的是，VS作为一个现代的编译器，不再支持您编译简单的单独的源代码--即使只有一个源代码文件，也必须用一个 **项目(project)**的形式来组织源码，最终一个或多个项目组织成一个大的单位—— **解决方案(solution)**。从源代码生成可执行文件是以解决方案为单位的。

我们建议您选择新建一个便于查看、修改、上传等操作的专用的文件夹来保存源代码，而不是使用默认的设置--这有可能让你在积累一段时间后无法从一堆文件里理清头绪。

![截屏2][pic_133_02]
![截屏3][pic_133_03]
 
我们不妨取Project名为"ProjectHelloWorld"。然后点击确定来创建项目。

在"解决方案资源管理器"中，可以看到这个新的解决方案（只包含一个项目）已经被打开，不过它还是空的。

右击项目名或子目录名"源文件"，在弹出菜单中选择"添加->新建项"，选择使用.cpp格式，我们不妨命名这个文件为hello.cpp，随后点击"添加"。

这样我们就添加了一个"hello.cpp"，它是项目中最关键最核心的源代码部分。

![截屏4][pic_133_04]

现在你可以从键盘上输入下面的这段程序。

```
#include <iostream>
using namespace std;
int main() {
    cout << "Hello, World!" ;
    system("pause");
    return 0;
}
```

![截屏5][pic_133_05]

随后，我们可以按下快捷键F5（请记住这个按键）来尝试编译并运行这段代码。典型的状况应该是下图所示。

![截屏6][pic_133_06]

我们可以简单地讲一讲为什么会有这样的运行结果。

在这一段标准的C++程序的开头，为一个C++程序的开始做了一些准备工作，在此暂时不做一些详细的介绍。程序的主要执行过程是在int main(){...}当中完成的。

cout << ... ;这一句简单地向屏幕输出内容，根据C++规范，每一条语句都必须用分号（注意区分中英文符号）作为结尾。这看起来还是清晰明了的。

system("pause");下达了一个指令，它的作用也表现的很明显：请求一个暂停。之所要有这一句，是因为这个简单程序在想要实现的功能--显示一句"hello, world"执行完毕之后，即将结束，糟糕的是，接下来VS就会在程序执行结束时立刻把这个对话框关掉--这将导致我们什么都看不到。暂停可以防止VS在我们来得及确认之前把窗口关掉。你也可以不局限于这种方法，更多方法此处限于篇幅暂不展开。

随后的return 0; 标志着程序的正常结束。这句话一般也可以不写（并不非常推荐这么做），因为当代编译器基本都可以自动为你补全这一句固定的话。

> 为什么是这样的界面？

> 相信许多人一开始对编程的希望并非如此。你可能希望做出一些看起来炫酷的东西，你可能希望能够很快地去满足自己以前的种种幻想--这一切很合理，但是尝试最快速度得到它们而不计较背后的原理，你很快就会陷入各种莫名其妙不可逾越的障碍。

> 也许这听起来有些令人沮丧，但是请面对面对这样的事实：虽然，利用一些玩具般的东西也可以做出图形化的界面，可是那通常也意味着已经有自动化的工具在背后为你生成了海量的代码--这可不是合理的学习途径。我们的编程学习必须从一些基本的内容开始，不能在基础未牢之时就试图踩在可视化界面这个巨人的肩膀上。

> 很快，如果你领会了接下来要学习的内容，你也将意识到，一个看起来可视化的界面也不过是一个包装。而我们，最需要的能力之一就是拆开包装，能看清楚事实上发生了什么事。一个美观的界面可能是对于非专业性的用户是友好的，然而，专业地，我们应该关注真正的核心--很多时候与界面无关。

> 早在这门科学建立之时，还没有如今的建立可视化桌面的需求。因此，传统上，我们不依赖一个个复杂的图形，而是输出一行又一行的字符，同时也可以接受字符的输入，很多时候它们都仅仅只是ASCII字符。虽然简陋，这样使我们能把事务集中于我们真正要解决的问题。这之后发展出的图形化界面实际上都是额外附加在这之上的内容，你可以比喻其为"胶囊的糖衣"（糖这个概念是时常出现的比喻，这提示我们总是更应该关注本质而不是似是而非的外在）。

> 即使在当今广泛流行的桌面操作系统，如Windows、Ubuntu Linux等等，也都保留有一个命令行模式的界面，一般统称为 **控制台(console)**。在这个界面字符提示逐行输出，你需要从键盘按一定规则输入命令，一般而言，你需要按下回车键来确认，这才能让计算机开始读取你的输入。

> 如果想变得专业一些，你需要打破自己对GUI的依赖。图形界面在你不清楚要干什么时可以更好的提示你，但是移动鼠标其实并不是多有效率的做法；当你明确自己要做什么，你也许会发现熟练从键盘传达指令实际上更加有效率。

我们再看一下上方的菜单，熟悉编程后我们可以很容易的区分每一栏包括的大致内容。

在调试栏下，可以看到我们按下的F5键对应的其实是"开始调试"命令。

注意到下面另一个按钮"开始执行（不调试）"

![截屏7][pic_133_07]
 
这涉及到另一些工程上的概念。 **调试(debug)**和 **发行(release)**是一组非常重要的概念。在开发过程中，有时我们希望软件的发行版本具有最优的性能，但是在测试阶段，我们希望一旦发生错误能够比较好的定位出错误来源--这两者有点矛盾。选择不同的编译类型会让编译器作出适应的不同选择。

值得一提的是，release版本会自动在上面这个程序末尾添加system("pause")指令。因此你为了手动调试而添加的这条语句不宜在发行的时候保留。另外，许多其他编译器有不同的准则，多数时候都不需要这一句命令。

此外编辑菜单的内容也是你需要多看几眼的--对于高效地编写与修改代码十分有帮助。

![截屏8][pic_133_08]

> 记住如下一些快捷操作键将会有极大的帮助。它们之中的大部分不仅可用于VS，并且是广泛适用于各个编辑器。
>
+ 剪切 Ctrl + X
+ 复制 Ctrl + C
+ 粘贴 Ctrl + V
+ 撤销 Ctrl + Z
+ 恢复 Ctrl + Y
+ 查找 Ctrl + F
+ 替换 Ctrl + H （有些编辑器如CodeBlocks对此例外）
+ 调试 F5 （许多编译器则是使用F9）
 
### Section 1-4 非常之路

不少常规性的教学有一个很大的缺点，就是评价标准极其不明确。这使得不少人在不断勉强地完成作业之后越来越积累不良的做法。如果你致力于切实提升自己的水平，有一些更好的方法。

在线评测系统能够为你解决许多问题。在一个在线评测系统中，一般你只需要提交符合要求的源代码，然后由系统来运行并根据运行结果来评价——通常是根据一组或多组给定的测试数据检验你的程序的输出是否正确。这种方法有助于你养成正确的解决问题的思路——按照一定的规约协约编写实现要求的功能的程序，而不是养成这样一种糟糕的模式--勉勉强强完成一些任务，寄希望于不严格的检查，也不讲究能否总是给出正确的结果，然后可能还有很多精力投入用一些蹩脚的文档或报告来糊弄。

###### 合适的在线评测网站

+ 比较适合一般水准的一个在线评测网站是LeetCode，它涵盖多方面的编程知识，可以比较全面的检查你的基础能力。我们不建议你按照随意的顺序做题--这会导致你经常遇到与你的精力集中位置不匹配的题目；有必要事先按照一定的研究做一些分类。

+ 牛客网是国内一个比较好的选择。

+ 如果希望提升自己的算法能力，或者通过超量学习来真正的提升效率，你可以选择poj.org和codeforces等网站（你可能需要相当一定的基础才能开始）。

###### 合适的书籍

阅览各个相关方面的的必读书目也是非常重要的基础，随时应当开始。尽管如此，我们仍优先你推荐先读完这本书的相关内容——也许是一个牢固基础的开始。

>一个简单的书单：（均有中文版）
>
+ 《C++ Primer Plus》/《C++ Primer》
+ 《Effective C++》
+ 《Learn Python The Hard Way》
+ 《Python基础教程》
+ 《Head First Java》
+ 《算法导论》
+ 《算法竞赛入门经典》&训练指南
+ 《挑战程序设计竞赛》

### Section 1-5 一些感悟

*“倘若以功利的眼光来看，不过是借助计算机，重新用另一种语言实现某种算法，以此来解决实际问题。但换种角度，编程是否就是在用另一种语言造物？上帝创造了宇宙，程序员创造了代码的世界。*

*“程序员面对着枯燥无味的代码，用户面对的是友好的交互界面。当科技进一步发展，程序员能否通过"编程"的手段来实现一个"可控的世界"？用代码勾勒清风、白云，模拟喜怒哀乐。此令问题无法深究，但即以能够通过编程来解决以兆计的问题，未来编程的方向必然向着实现更多、更广、更丰富的功能迈进。*

*“仅仅以敲代码、编写程序来定义编程是远远不够的。程序员敲下的代码世界，和诗中的、画中的、音乐中的、影视中的"另一个世界"大抵是相同的，可能区别是代码世界仍在襁褓，创造一个真正代码的世界需要耗费许许多多的经历。而想象力描绘出意境则轻松许多。同样的，如果编程能够成为和"想象力""诗句""画笔"等同样有力的武器，那么编程的世界未来可期，程序员也就是诗人、画家、歌者，更有甚者，应该称其为代码世界的神，因为他创造的世界是一个"可控体系"，他说要有光，于是便有了光。"*

*——孙\*\*\*\*\*\**


[1] : 着重参考了《全国青少年信息学奥林匹克竞赛培训教材（中学）》第1页内容。

[2] : 具体的分门别类其实是很有争议的内容，主要是概念本身的界定并不统一。


[pic_121_01]: img/pic_121_01.png
[pic_121_02]: img/pic_121_02.png
[pic_133_01]: img/pic_133_01.png
[pic_133_02]: img/pic_133_02.png
[pic_133_03]: img/pic_133_03.png
[pic_133_04]: img/pic_133_04.png
[pic_133_05]: img/pic_133_05.png
[pic_133_06]: img/pic_133_06.png
[pic_133_07]: img/pic_133_07.png
[pic_133_08]: img/pic_133_08.png

