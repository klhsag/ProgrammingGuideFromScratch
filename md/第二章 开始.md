## Chapter 2 开始

迈出编写属于你的程序的第一步——从做一些简单的运算开始。

### Section 2-1 Hello, world!

在上一章的简单例子中，我们使用了一个被称为"hello world"的简单程序。事实上，绝大部分语言都可以用着这样的形式来做一个精炼的介绍。

通常当你转移到一个新的环境，你可以用这个简单的程序来测试当前的环境，观察是否可以得到预期的结果。如果简单的程序无法按照预期的情况运行，则可能表明配置有误或者你使用了错误的方法。

一般地，在不同语言中"Hello World"有大体上一致而细节上并不相同的写法，在上一章中我们提供了经典的C++写法，下面是另一些语言的经典示范。

```
{ PASCAL语言, 
这是一个多行注释
}
program helloworld;
begin
    writeln('Hello, world!');
end.
```
```
/* C语言, 
这是多行注释 */
// VC的C编译器 和 所有C++也接受这种风格的单行注释
#include <stdio.h>
int main() {
    printf("Hello, World!");
    return 0;
}
```
```
// Java语言, 这是一行注释
public class hello {
    public static void main(String[] args) { 
        System.out.println( "Hello, World!");
    }
}
```
> ###### 为什么会有注释？

> 根据标准的百科式的解释："注释就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。"
注释中的内容在编译时会被忽略，它们存在的意义正如名称所言，能够起到提示的作用，这能避免抽象的代码不被人理解，并且你可以总结一大段代码的总体功能方便自己和其他人后来的理解，这样就不必每次都要详细地一行行读代码才能理解某段代码实际上做了什么。实际上，注释还经常用于在编写时临时地删除一段代码（而不必冒着找不回来原本所写内容这种风险）。

> 也有一种说法认为，"应当让代码自己注释自己"。一段写的足够好的代码能容易地让人理解其意图，而依赖注释不能特别地改变糟糕的代码有多难阅读和修改；不过必要时使用注释仍然是明智的。

> 不同语言遵循并不相同的注释规则，它们当中的绝大部分都支持使用"/*...*/"来进行多行注释和使用"//"来进行单行注释。（当然例外也不少见）

> 单行注释符号使这一行接下来的部分都被标记为注释；多行注释符号的使用则要当心，它们并不像第一直觉以为的那样可以在注释中嵌套注释（很容易理解这是为什么）。

即使未经过对这些语言的系统学习，看出这几段简单代码的大概含义还是很容易的。
实际上，大部分语言的helloworld只会更简单。这通常是最容易掌握的开始。

"Hello, world!"这一句显示在命令行上的输出看起来有些简陋和僵硬。

事实上在真正的工程中，我们往往不会用这种方法来给出我们的输出，有时是接入到一个GUI界面，有时是转换成一个文件或数据包用来进行数据的传递。然而，大部分语言都能提供这样简单的输出功能以提供便利。这样，你在初学阶段和某些需要做测试的时候，你可以利用这种简单的输出来很快的进行测试，不然想要获得来自程序的信息输出可就要麻烦的多了。

> 为何执行这样简单功能的程序包含一些看起来不相关的很多内容？

> 像python等脚本语言旨在为程序员提供便利，它们想要执行这个简单的功能一般只需要输入一句话然后回车就能执行。但是对于编译型语言则大不相同。我们的源代码文件有一定的组织结构。因此编译时要解决一个问题：程序的运行从何处开始？

> 虽然有时实际的实现随实际情况的千变万化而有所不同，不过各个主要的编译型语言都提供了默认的机制。除此之外，这些语言在每个程序的开始处还要做一些必要的准备工作。这其实并不奇怪，在内存中工作的程序想要能够调动你的屏幕来输出内容当然需要一些额外的准备工作，而编译型语言大部分希望你显式地指出使用的配置（而不是依赖某种默认配置）。

当然，只能输出一些事先指定的句子是远远不满足我们的需求的。接下来我们来可以看一看怎样做一个简单的计算工作，让计算机输出正确的计算结果。

### Section 2-2 A+B Problem

现在我们来看一看另一个入门程序的例子。

登陆poj.org，尝试开始提交一个入门级的程序：A+B Problem

（当然你首先要注册一个账号。注册方法在此就不赘述了。）

![截屏1][pic_220_01]

输入Problem ID为1000——poj题库当中的第一题。

![截屏2][pic_220_02]

一般来讲大部分题目题面是纯英文的（只有极少数可以选择中文——也包括这一题），不过通常不构成阅读障碍。第一题的页面提供了非常详细的信息来帮助你提交人生中的第一题--甚至包括了标准程序（标程，std）。现在你可以复制其中第一段程序，并把它 **提交(submit)**。

提交时注意选择所使用的语言，这里第一段程序是C++的，你可以选择G++（GNU C++编译器，建议选择）或C++（MSVC编译器）提交。

随后就会自动跳转到status list页面，通常会快就能评测出你的代码的正确性。完全通过会表示为 **Accepted**。

```
#include <iostream>
using namespace std;
int main() {
    int a, b;
    cin >> a >> b;
    cout << a+b << endl;
    return 0;
}
```

现在我们来考虑一下这道题目是如何被解决的。（虽然很简单，但是这样也能解释得比较简单一些）

正如在上一章中所述，程序的执行是开始于`int main(){...}`之中的。我们先来看看这个执行过程。

首先，我们先解释一个先前还没有详细解释的概念——语句。

语句是程序执行的单位，在C++中，强制规定，每一条语句都必须以";"结尾，也就是说分号不是分隔符而是结束符，它是完整语句必须包括的基本单位。一般地，语句必须严格的按照顺序执行（实际上是采取一个宽松一点的等效条件——必须与按顺序执行有完全相同效果）。

> 提示：
> 新手常犯的错误之一是混淆输入法——请注意，你的程序要素必须是用半角符号（英文标点）写成的，不可错用中文标点。

大部分语言都遵循像C++这样的规则——编译器并不真的在乎你写的空格与换行，编译器在处理时会统一的把连续的“空白”（ **whitespace**, 包括空格，回车，制表符(tab)）当做一个空格来处理，空白存在的作用是通过缩进增强代码的可读性。你必须使用规定的符号来表达格式。这样即使把所有代码都写在一行对于编译器来讲也没什么区别——只对读和改程序的人有区别。

现在我们来看看具体的这几条语句。

`int a, b;` 这一句被称作“变量声明”，联系数学上的知识，当你需要引入一个未知量时，你会写“设x为……”之类的话，在编程中也是如此。C++作为一门有一定严谨要求的语言，要求你必须事先声明所用的变量，而不可随意引入。这一条语句的具体含义是声明两个整数类型的变量（integer, 简称 **整型**），分别是a和b，逗号（英文逗号）的作用是把a和b并列，这可以避免把简短的意图拆分成`int a; int b;` 两句话。

> 为什么要声明一个整型变量？

> 这是基于计算机内部的实现机理。尽管在数学中，实数已经是为我们所熟悉很久的数字，但是在计算机中，整数才是最自然的表示，如果想要表示小数，则有许多麻烦。

紧接下来一句话是C++给出的标准的读入数据的做法，通过`cin >> ... >> ... ;` 的形式，根据填入的变量类型，你这些可以从标准输入中读取一系列的数据，对应地赋值（assign）给变量。通常这个标准输入是指控制台中由键盘输入数据，并按下回车确认。然而在poj中，有专门的方法来替换这个标准输入，用预先构造好的测试数据作为输入来检验你的程序的正确性，并且一般来说你不能获取到这个测试数据，这是为了避免作弊和保护知识产权。

随后的`cout << ... << ... ;` 则是标准的输出形式。a+b是一个式子，或者专业地说，这是一个“运算表达式”，它会有一个运算结果，这个结果也是一个隐含的变量，我们没有立刻提取出这个变量的具体内容，而是直接把它输出，这减少了不必须的中转过程。随后的`endl`标志着一个换行（endline），一般来讲它对应输出一个换行符。

> 在C++中，你一般只需要保证在开始使用变量之前事先声明，大部分语言也是这样。但是也有众多例外。

> PASCAL语言和C99（顾名思义，是一个1999年确定的标准）之前的C语言都明确规定变量必须在程序的开头就声明，这么做的好处是一下就能看清楚用了什么变量，坏处是不知道哪里用到它们。事实上，一开始这样做的理由时比较久远的年代计算机的性能还不足以支持复杂的编译。

> 以Python等脚本语言为代表的许多语言不需要变量声明，这使得它们更适合高速开发。但是这种做法是有弊端的，可以看下边一个例子：

> ```
int RegiterCurNum;
...
RegiterCurNum = something;
...
RegiterCurrNum = RegiterCurrNum + 1;
```

> 如果是在C++这样严格的语言中，很快就能发现这之中隐藏的拼写错误——编译器会给出有一个变量未经过声明就被使用的提示；然而如果是一个不需要声明变量的语言，事情恐怕就没有这么简单了——编译器将自动生成一个新的变量，这样产生的bug很可能是隐藏的，极难被发现和搜索。

那么，cin和cout是从何而来，凭什么可以用作输入输出呢？这就是最开始的一句`#include<iostream>` 的作用了。注意到这一句并不带";"符号，因为它并不是一条C++语句，而是用于给编译器指示的 **预编译(Precompiling)**指令。预编译指令以#开头。`#include` 是最基本最常用的预编译指令，顾名思义它表示包含一个 **头文件(header file)**。这里我们包含了一个被称为“iostream”的头文件，一对“<>”的格式表示这是一个C++标准库的文件。iostream包含了C++的标准的输入输出程序，当你的程序中写了一处`#include<iostream>`，编译器在处理时会从标准库中搜索出iostream文件的内容，这短短的一行指令将会被用标准库的iostream文件的全部内容来替换掉。当然，iostream文件里本身也包含一些编译指令，它们接下来也会被按照顺序执行。

`using namespace std;` 这一句详细解释的话略微复杂。简单说来，iostream提供的并非cin和cout，而是用 **名称空间(namespac)**std包裹的`std::cin` 和`std::cout`。这一句话简化了接下来的工作。

> `#include` 是C首创的文件引用方式。在当时，这是一个突破性的想法，那之前许多大型程序有上万行代码不便利于维护，这个创造使得代码可以划分为多个文件，更方便管理。

> 然而，与其他现代语言对比，这个做法就很原始了。`#include`只能直接把指定的文件的所有内容都囊括进编译目标，若果被include的文件当中又include了不少其他文件，累积下来就会把大量原本不一定用到的代码全都引入过来。典型的例子就是我们刚刚使用的`#include<iostream>`，视编译器的不同而定，它实际上至少包含了数千行代码。这是C++编译缓慢的重要原因之一。

> 不幸的是，为了兼容C，C++一直并且还将只会使用这种做法。有必要记住：它的本质实际上是完全的文本替换。

做完这道题目之后，poj上接下来的题目就相对复杂了，因此我们还是暂时离开poj，考虑一些简单的命题。

### Section 2-3 Simple Math Problems

考虑做一些简单的数学计算。不妨从尽可能简单的入手。

一个简单的问题：已知一个圆的半径，求其周长与面积。

```
#include <iostream>
using namespace std;
int main() {
	double r, c, s;
	const double PI = 3.141592654;
	cin >> r; 
	c = 2 * PI * r;
	s = PI * r * r;
	cout << "The C of the Circle is " << c << endl;
	cout << "The S of the Circle is " << s << endl;
	return 0;
}
```

大致浏览一下这段代码，相信即使还对一些细节不太了解，你也能大致了解意图：这段代码包含了r, c, s, PI 这几个量，根据我们了解的数学符号的惯例，这分别表示半径周长，面积和圆周率。

显然，第一行是一组变量声明。考虑到圆周率是一个无理数，我们要进行的显然不可能是纯整数运算了。因此这里的变量声明类型不是`int`而是`double`。double是推荐使用的一个浮点数类型，计算机内部运用类似于科学计数法的方法来记录一个浮点数。

> 浮点数的使用实际上有很大局限。据说，冯·诺依曼曾建议不要把浮点数作为一个标准。不过它的至少还是能简化我们的一般运算。

> 类似于科学计数法中把一个数表示为一个1到10之间的数与一个10的整数次幂的乘积，浮点数把一个数字记录为一个整数和一个2的整数次幂的乘积。

> 这个方法有天然的缺陷，一个十进制的不循环小数，一般地，并不是一个二进制不循环小数。误差很难避免。因此浮点数的不恰当使用将会导致精度损失。

> 如果你想要记录一些“定点数”的数据，比如一个单位的价格，使用浮点数可以说是非常不明智的选择。如果使用“元”作为单位，那么这是一个固定两位小数的数字——真正可靠一点的做法就是记录下以“分”为单位的整数值，否则你就连这两位小数也不一定记录得精准了。

第二行看起来似乎也是一个变量声明，不过在语句的最前面多了一个"const"。这里的`const`是一个限定符。const 限定指出PI并不是一个“变”量，而是一个常量，也就是不会变更的量。在这里设置PI是常量是当然的——我们都知道pi是一个固定的数学常数。不过const也可以有更多用处。不能假设使用者不会想要变更PI而不设置const限定符，设置const限定符有助于确认该变量是一个常量。这可以防止一些错误的修改（尝试修改const修饰的变量将会是一个编译错误）。

因为常量不可被修改，所以你必须在声明的同时指定它的取值，这被称为 **初始化(initialize)**。事实上，一般的变量也可以被初始化，不过还能在随后被修改。

> 秉承自C语言，有另一种定义PI这种常量的做法

> 在程序的开头部分，可以使用这样一句编译指令`#define PI 3.1415926534` 来定义一个 **宏(macro)**。这个指令会让编译器在接下来的编译过程中把所有遇到的"PI"文本替换成"3.1415926534"。

> 这个做法不在C++中被推荐。编译器能够自动把合适的const修饰的常量定义展开成这种形式。而宏定义的常量是以文本替换形式嵌入的，这会导致发生一些错误时很难检查原因。

`cin >> r;` 读取了半径。

接下来两行执行了称为 **赋值(assign)**的操作。

在C++中，使用"="符号来专门表示“赋值”这一概念。简单地说，赋值运算符会计算出"="符号右边的表达式的值，并把这个值 **赋(assign)**给左边的变量。

> 一般地，赋值符号左边需要是一个变量或者类似的东西，必须可以接受对应的修改，统称为 **左值(lvalue)**。对应地右边的表达式算出的结果称为 **右值(rvalue)**。此处仅作介绍。

C++中允许链式赋值，比如像这样写`a = b = 0;`。这是因为在C++中赋值语句本身也是一个表达式，也有值。在这条语句中，首先执行`b = 0`这个内容；随后，b将会作为赋值表达式的结果返回，紧接着发生了`a = b`的执行。

> 注意：绝大多是语言并不支持像C++这样赋值语句本身也可作为表达式的特性。很多也不支持链式赋值。

`s = PI * r * r;` 是必要的写法，C++不支持直接进行乘方操作。

接下来的两行cout的语句用了一些带提示语的技法，通过穿插文字与数据的输出，你的程序的运行看上去会更容易搞懂一些。不过这点花哨的东西其实没什么用，在console上编程就是为了让你注重本质，在这里讲究程序与用户的交互意义不大。此外切记切记，不要在poj那样规格化输入输出的测试环境中写这样的代码。



[pic_220_01]: img/pic_220_01.png
[pic_220_02]: img/pic_220_02.png





