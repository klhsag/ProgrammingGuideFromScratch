## Chapter 2 开始

迈出编写属于你的程序的第一步——从做一些简单的运算开始。

### Section 2-1 Hello, world!

在上一章的简单例子中，我们使用了一个被称为"hello world"的简单程序。事实上，绝大部分语言都可以用着这样的形式来做一个精炼的介绍。

通常当你转移到一个新的环境，你可以用这个简单的程序来测试当前的环境，观察是否可以得到预期的结果。如果简单的程序无法按照预期的情况运行，则可能表明配置有误或者你使用了错误的方法。

一般地，在不同语言中"Hello World"有大体上一致而细节上并不相同的写法，在上一章中我们提供了经典的C++写法，下面是另一些语言的经典示范。

```
{ PASCAL语言, 
这是一个多行注释
}
program helloworld;
begin
    writeln('Hello, world!');
end.
```
```
/* C语言, 
这是多行注释 */
// VC的C编译器 和 所有C++也接受这种风格的单行注释
#include <stdio.h>
int main() {
    printf("Hello, World!");
    return 0;
}
```
```
// Java语言, 这是一行注释
public class hello {
    public static void main(String[] args) { 
        System.out.println( "Hello, World!");
    }
}
```
> ###### 为什么会有注释？
>
> 根据标准的百科式的解释："注释就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。"
注释中的内容在编译时会被忽略，它们存在的意义正如名称所言，能够起到提示的作用，这能避免抽象的代码不被人理解，并且你可以总结一大段代码的总体功能方便自己和其他人后来的理解，这样就不必每次都要详细地一行行读代码才能理解某段代码实际上做了什么。实际上，注释还经常用于在编写时临时地删除一段代码（而不必冒着找不回来原本所写内容这种风险）。
>
> 也有一种说法认为，"应当让代码自己注释自己"。一段写的足够好的代码能容易地让人理解其意图，而依赖注释不能特别地改变糟糕的代码有多难阅读和修改；不过必要时使用注释仍然是明智的。
>
> 不同语言遵循并不相同的注释规则，它们当中的绝大部分都支持使用"/*...*/"来进行多行注释和使用"//"来进行单行注释。（当然例外也不少见）
>
> 单行注释符号使这一行接下来的部分都被标记为注释；多行注释符号的使用则要当心，它们并不像第一直觉以为的那样可以在注释中嵌套注释（很容易理解这是为什么）。

即使未经过对这些语言的系统学习，看出这几段简单代码的大概含义还是很容易的。
实际上，大部分语言的helloworld只会更简单。这通常是最容易掌握的开始。

"Hello, world!"这一句显示在命令行上的输出看起来有些简陋和僵硬。

事实上在真正的工程中，我们往往不会用这种方法来给出我们的输出，有时是接入到一个GUI界面，有时是转换成一个文件或数据包用来进行数据的传递。然而，大部分语言都能提供这样简单的输出功能以提供便利。这样，你在初学阶段和某些需要做测试的时候，你可以利用这种简单的输出来很快的进行测试，不然想要获得来自程序的信息输出可就要麻烦的多了。

> 为何执行这样简单功能的程序包含一些看起来不相关的很多内容？
>
> 像python等脚本语言旨在为程序员提供便利，它们想要执行这个简单的功能一般只需要输入一句话然后回车就能执行。但是对于编译型语言则大不相同。我们的源代码文件有一定的组织结构。因此编译时要解决一个问题：程序的运行从何处开始？
>
> 虽然有时实际的实现随实际情况的千变万化而有所不同，不过各个主要的编译型语言都提供了默认的机制。除此之外，这些语言在每个程序的开始处还要做一些必要的准备工作。这其实并不奇怪，在内存中工作的程序想要能够调动你的屏幕来输出内容当然需要一些额外的准备工作，而编译型语言大部分希望你显式地指出使用的配置（而不是依赖某种默认配置）。

当然，只能输出一些事先指定的句子是远远不满足我们的需求的。接下来我们来可以看一看怎样做一个简单的计算工作，让计算机输出正确的计算结果。

### Section 2-2 A+B Problem

现在我们来看一看另一个入门程序的例子。

登陆poj.org，尝试开始提交一个入门级的程序：A+B Problem

（当然你首先要注册一个账号。注册方法在此就不赘述了。）

![截屏1][pic_220_01]

输入Problem ID为1000——poj题库当中的第一题。

![截屏2][pic_220_02]

一般来讲大部分题目题面是纯英文的（只有极少数可以选择中文——也包括这一题），不过通常不构成阅读障碍。第一题的页面提供了非常详细的信息来帮助你提交人生中的第一题--甚至包括了标准程序（标程，std）。现在你可以复制其中第一段程序，并把它 **提交(submit)**。

提交时注意选择所使用的语言，这里第一段程序是C++的，你可以选择G++（GNU C++编译器，建议选择）或C++（MSVC编译器）提交。

随后就会自动跳转到status list页面，通常会快就能评测出你的代码的正确性。完全通过会表示为 **Accepted**。

```
#include <iostream>
using namespace std;
int main() {
    int a, b;
    cin >> a >> b;
    cout << a+b << endl;
    return 0;
}
```
你也可以先在自己的编译器上测试这段代码是如何工作的。

现在我们来考虑一下这道题目是如何被解决的。（虽然很简单，但是这样也能解释得比较简单一些）

正如在上一章中所述，程序的执行是开始于`int main(){...}`之中的。我们先来看看这个执行过程。

首先，我们先解释一个先前还没有详细解释的概念——语句。

语句是程序执行的单位，在C++中，强制规定，每一条语句都必须以";"结尾，也就是说分号不是分隔符而是结束符，它是完整语句必须包括的基本单位。一般地，语句必须严格的按照顺序执行（实际上是采取一个宽松一点的等效条件——必须与按顺序执行有完全相同效果）。

> 提示：
> 新手常犯的错误之一是混淆输入法——请注意，你的程序要素必须是用半角符号（英文标点）写成的，不可错用中文标点。

大部分语言都遵循像C++这样的规则——编译器并不真的在乎你写的空格与换行，编译器在处理时会统一的把连续的“空白”（ **whitespace**, 包括空格，回车，制表符(tab)）当做一个空格来处理，空白存在的作用是通过缩进增强代码的可读性。你必须使用规定的符号来表达格式。这样即使把所有代码都写在一行对于编译器来讲也没什么区别——只对读和改程序的人有区别。

现在我们来看看具体的这几条语句。

`int a, b;` 这一句被称作“变量声明”，联系数学上的知识，当你需要引入一个未知量时，你会写“设x为……”之类的话，在编程中也是如此。C++作为一门有一定严谨要求的语言，要求你必须事先声明所用的变量，而不可随意引入。这一条语句的具体含义是声明两个整数类型的变量（integer, 简称 **整型**），分别是a和b，逗号（英文逗号）的作用是把a和b并列，这可以避免把简短的意图拆分成`int a; int b;` 两句话。

> 为什么要声明一个整型变量？
>
> 这是基于计算机内部的实现机理。尽管在数学中，实数已经是为我们所熟悉很久的数字，但是在计算机中，整数才是最自然的表示，如果想要表示小数，则有许多麻烦。

紧接下来一句话是C++给出的标准的读入数据的做法，通过`cin >> ... >> ... ;` 的形式，根据填入的变量类型，你这些可以从标准输入中读取一系列的数据，对应地赋值（assign）给变量。通常这个标准输入是指控制台中由键盘输入数据，并按下回车确认。然而在poj中，有专门的方法来替换这个标准输入，用预先构造好的测试数据作为输入来检验你的程序的正确性，并且一般来说你不能获取到这个测试数据，这是为了避免作弊和保护知识产权。

> 注意：既然a和b都是整型变量，那么它们当然只能接受整数作为输入。如果你在自己的编译器上调试这段程序，你将看到，尝试输入非整数的内容会导致报错，程序将中断。

随后的`cout << ... << ... ;` 则是标准的输出形式。a+b是一个式子，或者专业地说，这是一个“运算表达式”，它会有一个运算结果，这个结果也是一个隐含的变量，我们没有立刻提取出这个变量的具体内容，而是直接把它输出，这减少了不必须的中转过程。随后的`endl`标志着一个换行（endline），一般来讲它对应输出一个换行符。

> 在C++中，你一般只需要保证在开始使用变量之前事先声明，大部分语言也是这样。但是也有众多例外。
>
> PASCAL语言和C99（顾名思义，是一个1999年确定的标准）之前的C语言都明确规定变量必须在程序的开头就声明，这么做的好处是一下就能看清楚用了什么变量，坏处是不知道哪里用到它们。事实上，一开始这样做的理由时比较久远的年代计算机的性能还不足以支持复杂的编译。
>
> 以Python等脚本语言为代表的许多语言不需要变量声明，这使得它们更适合高速开发。但是这种做法是有弊端的，可以看下边一个例子：
>
>
```
int RegiterCurNum;
...
RegiterCurNum = something;
...
RegiterCurrNum = RegiterCurrNum + 1;
```
>
> 如果是在C++这样严格的语言中，很快就能发现这之中隐藏的拼写错误——编译器会给出有一个变量未经过声明就被使用的提示；然而如果是一个不需要声明变量的语言，事情恐怕就没有这么简单了——编译器将自动生成一个新的变量，这样产生的bug很可能是隐藏的，极难被发现和搜索。

那么，cin和cout是从何而来，凭什么可以用作输入输出呢？这就是最开始的一句`#include<iostream>` 的作用了。注意到这一句并不带";"符号，因为它并不是一条C++语句，而是用于给编译器指示的 **预编译(Precompiling)**指令。预编译指令以#开头。`#include` 是最基本最常用的预编译指令，顾名思义它表示包含一个 **头文件(header file)**。这里我们包含了一个被称为“iostream”的头文件，一对“<>”的格式表示这是一个C++标准库的文件。iostream包含了C++的标准的输入输出程序，当你的程序中写了一处`#include<iostream>`，编译器在处理时会从标准库中搜索出iostream文件的内容，这短短的一行指令将会被用标准库的iostream文件的全部内容来替换掉。当然，iostream文件里本身也包含一些编译指令，它们接下来也会被按照顺序执行。

`using namespace std;` 这一句详细解释的话略微复杂。简单说来，iostream提供的并非cin和cout，而是用 **名称空间(namespac)**std包裹的`std::cin` 和`std::cout`。这一句话简化了接下来的工作。

> `#include` 是C首创的文件引用方式。在当时，这是一个突破性的想法，那之前许多大型程序有上万行代码不便利于维护，这个创造使得代码可以划分为多个文件，更方便管理。
>
> 然而，与其他现代语言对比，这个做法就很原始了。`#include`只能直接把指定的文件的所有内容都囊括进编译目标，若果被include的文件当中又include了不少其他文件，累积下来就会把大量原本不一定用到的代码全都引入过来。典型的例子就是我们刚刚使用的`#include<iostream>`，视编译器的不同而定，它实际上至少包含了数千行代码。这是C++编译缓慢的重要原因之一。
>
> 不幸的是，为了兼容C，C++一直并且还将只会使用这种做法。有必要记住：它的本质实际上是完全的文本替换。

做完这道题目之后，poj上接下来的题目就相对复杂了，因此我们还是暂时离开poj，考虑一些简单的命题。

### Section 2-3 Simple Math Problems

考虑做一些简单的数学计算。不妨从尽可能简单的入手。

一个简单的问题：已知一个圆的半径，求其周长与面积。

```
#include <iostream>
using namespace std;
int main() {
	double r, c, s;
	const double PI = 3.141592654;
	cin >> r; 
	c = 2 * PI * r;
	s = PI * r * r;
	cout << "The C of the Circle is " << c << endl;
	cout << "The S of the Circle is " << s << endl;
	return 0;
}
```

大致浏览一下这段代码，相信即使还对一些细节不太了解，你也能大致了解意图：这段代码包含了r, c, s, PI 这几个量，根据我们了解的数学符号的惯例，这分别表示半径周长，面积和圆周率。

显然，第一行是一组变量声明。考虑到圆周率是一个无理数，我们要进行的显然不可能是纯整数运算了。因此这里的变量声明类型不是`int`而是`double`。double是推荐使用的一个浮点数类型，计算机内部运用类似于科学计数法的方法来记录一个浮点数。

> 浮点数的使用实际上有很大局限。据说，冯·诺依曼曾建议不要把浮点数作为一个标准。不过它的至少还是能简化我们的一般运算。
>
> 类似于科学计数法中把一个数表示为一个1到10之间的数与一个10的整数次幂的乘积，浮点数把一个数字记录为一个整数和一个2的整数次幂的乘积。
>
> 这个方法有天然的缺陷，一个十进制的不循环小数，一般地，并不是一个二进制不循环小数。误差很难避免。因此浮点数的不恰当使用将会导致精度损失。
>
> 如果你想要记录一些“定点数”的数据，比如一个单位的价格，使用浮点数可以说是非常不明智的选择。如果使用“元”作为单位，那么这是一个固定两位小数的数字——真正可靠一点的做法就是记录下以“分”为单位的整数值，否则你就连这两位小数也不一定记录得精准了。

第二行看起来似乎也是一个变量声明，不过在语句的最前面多了一个"const"。这里的`const`是一个限定符。const 限定指出PI并不是一个“变”量，而是一个常量，也就是不会变更的量。在这里设置PI是常量是当然的——我们都知道pi是一个固定的数学常数。不过const也可以有更多用处。不能假设使用者不会想要变更PI而不设置const限定符，设置const限定符有助于确认该变量是一个常量。这可以防止一些错误的修改（尝试修改const修饰的变量将会是一个编译错误）。

因为常量不可被修改，所以你必须在声明的同时指定它的取值，这被称为 **初始化(initialize)**。事实上，一般的变量也可以被初始化，不过还能在随后被修改。

> 秉承自C语言，有另一种定义PI这种常量的做法
>
> 在程序的开头部分，可以使用这样一句编译指令`#define PI 3.1415926534` 来定义一个 **宏(macro)**。这个指令会让编译器在接下来的编译过程中把所有遇到的"PI"文本替换成"3.1415926534"。
>
> 这个做法不在C++中被推荐。编译器能够自动把合适的const修饰的常量定义展开成这种形式。而宏定义的常量是以文本替换形式嵌入的，这会导致发生一些错误时很难检查原因。

`cin >> r;` 读取了半径。

接下来两行执行了称为 **赋值(assign)**的操作。

在C++中，使用"="符号来专门表示“赋值”这一概念。简单地说，赋值运算符会计算出"="符号右边的表达式的值，并把这个值 **赋(assign)**给左边的变量。

> 一般地，赋值符号左边需要是一个变量或者类似的东西，必须可以接受对应的修改，统称为 **左值(lvalue)**。对应地右边的表达式算出的结果称为 **右值(rvalue)**。此处仅作介绍。

C++中允许链式赋值，比如像这样写`a = b = 0;`。这是因为在C++中赋值语句本身也是一个表达式，也有值。在这条语句中，首先执行`b = 0`这个内容；随后，b将会作为赋值表达式的结果返回，紧接着发生了`a = b`的执行。

> 注意：绝大多是语言并不支持像C++这样赋值语句本身也可作为表达式的特性。很多也不支持链式赋值。

`s = PI * r * r;` 是必要的写法，C++不支持直接进行乘方操作。

接下来的两行cout的语句用了一些带提示语的技法，通过穿插文字与数据的输出，你的程序的运行看上去会更容易搞懂一些。不过这点花哨的东西其实没什么用，在console上编程就是为了让你注重本质，在这里讲究程序与用户的交互意义不大。此外切记，不要在poj那样规格化输入输出的测试环境中写这样的代码。

### section 2-4 ASCII字符

```
#include <iostream>
using namespace std;
int main() {
	char ch;
	cin >> ch;
	cout << "We've got an ASCII character: " << ch << endl;
	return 0;
}
```

尝试运行上面这段代码。

> 注意，在现代windows系统下你可以在控制台中通过输入法输入中文。一般情形下，你应该把输入法关闭。

这段代码的作用是让你从键盘输入字符，然后重新输出你输入的第一个字符。如果你仅仅是立即按下了回车键，你依然被看做完成了输入——因为回车也是一个字符。

一般情形下，不使用输入法，你可输入的全部字符（不包括shift键方向键等控制命令）均是ASCII码，它们是任何计算机都要支持的标准字符集，每个字符只占用一个字节，并且只占一个字节八位中的后七位，第一位为零（从而可以拓展其他字符集），一共有128个互不相同的编码，大多数是可以显示在屏幕上的编码，也有一些特殊编码。

`char` 是C++基本的字符类型，它只占用一个字节，所以原则上只能存储ASCII。各种标准输入输出支持基本上也是基于此的。

> 让程序可以国际化，字符集的兼容一直是一个问题。一直以来，C++缺乏内置的多语言支持。
>
> 我们不建议你在cout语句中写中文，即使看上去没有输出乱码也不意味着经过了正确的转换流程——你恐怕自己也不知道在使用什么字符集。这个复杂的问题不是在源代码中写中文可以解决的，如果你养成这样的习惯，隐藏的问题可能在任何时候爆发。你以后可以了解到一些成熟的做法。


### Section 2-5 命名，类型

正如在前面的例子里面所能看到的那样，你采用类似于数学中那样的形式化的语言来描述你的流程。不过，对于计算机而言，你的做法不像数学中那样自由，而是有一系列严格的规则约束。

#### 2-5-1 命名

在数学中，变量一般用a, u, v, p, x, y, z... 这样的字母，但是在一个稍大规模的工程里，简单的单个字母数目未免太少了。此外，我们希望变量名可以直观地在一定程度上表现出其代表的含义，这样我们就不需要通过查找注释、文档乃至联系上下文了解某个语句的含义。一般来说，使用单个字母作为变量名称是不被建议的。

在C++和其他大多数语言中，变量的命名遵循简单的规范——必须有若干个字母、数字和下划线('_'符号)组成，并且必须用字母或下划线而不是数字开头。详细情况请读者自行查找资料。\^[1]

例如，变量命名`a`, `a1`, `a_`, `s_1_3_z`, `_pz`之类都是合法的。

> 注意：一般来说，不建议用下划线作为变量名的开头，这是因为他们可能会和标准库变量以及编译器的生成符号产生混淆。

不过，除此之外，还有一些特殊规定。考虑这样一个语句，`int a;`代表声明一个整型变量a。如果我们允许`int`也可以作为变量名，那会发生什么呢？肯定容易造成极大的混乱。因此大部分语言中都有“保留字”的概念，你不可以把语言中有特定作用的单词用作变量名。不过可喜的是，大部分编辑器都能够通过代码高亮来提示语言的保留字，减少了你的烦恼。此外，你自己又尝试定义多个名称完全相同的变量当然也是不行的。

#### 2-5-2 简单类型

另一个需要在此处作一点说明的是类型概念。抽象地说，变量的类型决定了该变量的取值范围。一个整型变量其取值必须是一个整数。并且，考虑一下实际情形，计算机要分配内存给每个变量来存储数据，所以可存储的数字大小也是有限的。一般来说，C++上的int在32位以及64位系统上都使用4个字节（一共32位）来存储，也就是有2^32 次方种取值可能，因此int型变量取值范围是-2^31 ~(2^31 -1)，低于10^9 这个数量级的数字一般来说比较安全，通常情形这足够我们使用了。

> int 不足够时，一般可以先考虑long long，该类型占8个字节，能表示-2^63 ~(2^63 -1)范围的整数。
>
> 有时，我们需要的表达的数字一定是自然数，不需要负数。C++提供一个unsigned前缀，unsigned int(一般可简写为unsigned)和unsigned long long的取值范围从0开始。

浮点数则要复杂一些，遵循一个既定的标准，浮点数的存储分成底数和指数两个部分，并且这两个部分都是分正负的。想象指数取到较为极限数值时在数字大小比较上能造成怎样的混乱，你就知道浮点数实际上是多么不精密的玩意了。常见的浮点类型包括float和double，我们当下的建议是，几乎任何情形，你都应该尽可能使用double来替代float，因为与整数类型不同，整数的存储宽度提升只增加绝对值的最大取值范围，但是对于浮点数这是关系到取值精度的重大问题。

字符类型同样是一个基本类型——尽管在C++中实际上并不基本。如今许多实际应用（尤其是互联网应用）的关键部分在字符的处理上，但是C++并不以此为长——C++更适合处理更抽象一些的数据，用来对连串的文本进行分析则并不顺手，更不要说多语言支持比较糟糕了。事实上，在C++中，char的本质是一个整数，但是只占一个字节，其取值范围为-128~127，可以表示全部的ASCII编码，负数部分可以用做判别一些控制字符。特别地，-1通常表示输入结束（在windows的console下按Ctrl+Z来转码）。

#### 2-5-3 类型转换

下面这行代码可以输出字符的ASCII编码。

`cout << int(ch) ;`

也可以这样写：

`cout << (int)ch ; // C-style `

在比较新的标准中推荐这样做：

`cout << static_cast<int>(ch) ; //指定转换类型是静态转换 `

这种写法几乎为C/C++独有，也是其功能强大的根本（同时也是隐患）。

这种做法称为强制类型转换，按照一定的规则，强行地把一种类型的数据解释为另一种类型。前两行是C语言常用的写法，最后一行则是C++的推荐做法——更显式地指出了存在一个转换并指明转换遵循的规则种类。

除此之外，C++还存在隐式类型转换，比如，你可以写这样的代码。

```
char ch;
cin >> ch;
int a = ch;
cout << a;
```
这同样能实现上面的功能。char类型变量被隐含地转换了。

> 隐式转换在不少情况下是有作用的。但是大部分情形应尽量避免。写代码时要特别当心，当出现了不在意料之内的隐式类型转换就可能导致非常隐蔽的错误。

最重要的一种类型转换是在整数和浮点数之间。

考虑这样一段代码。

```
cout << 7/2 ;
```

这段代码不会输出3.5，事实上它输出3。因为7和2都是隐含的整数类型变量，因此使用整数除法，7除以2等于3余1。使用`7%2` 这样的代码可以计算整数除法的余数。

> 正整数计算的除法容易理解，但是负数的整数除法呢？
>
> 事实上这没有公认的数学事实。
>
> 首先，确认这样一个基本事实，a/b=c, a%b=r, 则 a=b*c+r 。这个规则肯定是底线。
>
> + 以PASCAL/C/C++/Java等编译型语言为代表，整数除法的规则是商向零取整。例如，-7/2=3，余数是-1；-7/-2=3，余数也是-1。在这种情况下，除法的计算与乘法相似，可以看做绝对值相除，符号则是同正异负，而余数的符号始终与被除数一样。这种观念是除法观念。
> + 以Python, Perl, Lua 等脚本语言为代表，除法规则是向负无穷取整，例如 -7/2=-4余1, -7/-2=3余-1。这种情况余数符号始终与除数一致。这种观念是取模观念。
>
> 在运算可能包含负数时一定要考虑清楚在负数上的情形。

想要输出小数，有多种可行手法。

```
cout << 7.0/2; // ok
cout << 7/2.0; // ok
cout << 7/(double)2; // ok
cout << double(7/2); // wrong, just turn "int(3)" to "double(3.0)"
```

在C++中，隐藏的规则是，不同类型的数字相互运算时，首先char转换为short int（一种更短的int），随后unsigned如果不一致则被去掉，数据范围不一致时，小的会被转换为大的。

现在考虑这样一个例子：有两个可能足够大的int型数据a和b，它们如果相乘，可能会 **溢出(overload)**数据范围，因此有必要改用long long变量保存乘积。

有一种想当然的错误写法：

```
long long c = a * b; // a, b are ints;
```
在有些语言里这么做是可行的，但在C++里这是不正确的写法，因为a*b当中a和b都是int，因此乘积只能是int型变量——在被赋值给c前已经发生了溢出。

必须像这样改写。

```
long long c = (long long)(a) * b;
```

[1] : 可能有待补充一个链接

[pic_220_01]: img/pic_220_01.png
[pic_220_02]: img/pic_220_02.png





