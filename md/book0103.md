## Chapter 3 结构化编程

开始在程序中书写一些结构。

### Section 3-1 用goto模拟流程图

上一章我们学习了一些基本的语句写法。包括如何简单地定义一个变量，进行四则运算，把运算结果赋值给另一个变量以及输入和输出。距离一个功能相对完善的程序还有欠缺。

考虑一下我们常见的流程图的结构，不难发现我们还缺少一种起控制流程走向作用的语句。如果不能控制程序的走向，我们就只能按照书写的顺序执行每一条语句代表的指令，这可实现不了任何稍微复杂一点的功能。

因此，最早出现的控制语句就是单纯地起到 **跳转(jump)** 作用的语句，称为goto语句。

单独的goto语句通常不能起到控制作用，必须要配合可以进行判断的功能，这通常是if语句的作用。

我们来看下面这幅流程图是如何用goto语句转换为C++语言的。

![流程图演示][pic_310_01]

```
...
int main(){
	int t = 0;
	int k = 0;

T_OVER_105_NO:
	t = t + k;
	if (t>105) goto T_OVER_105_YES;
	else goto T_OVER_105_NO;

T_OVER_105_YES:
	cout << k;

	return 0;
}
```

C++允许我们不加预先声明地使用一个标记。基本上，标记仅仅只是标记而已。当你使用goto语句来指向一个标记，实际执行到此处时就会跳转到标记处，从标记处继续执行指令。实际上，CPU使用的汇编指令就是这样工作的。

>  `if ... ... else ...` 语句是一个分支结构，允许你根据一个逻辑表达式是否成立来进行分支选择。稍后我们会进一步展开对这个语句的详细解释。
>
>事实上，在goto风格中，if-else语句只需要进行简单的跳转的选择。

看起来我们似乎不错地把这个流程图实现了。不过，恐怕你也注意到，和流程图相比，代码写成这样恐怕不够美观易读。由于代码是在线性的一维上展开，这种跳转形式就必须要非常仔细地阅读跳转过程才能理解，并且可能要写很多goto来把不同的。倘若多个goto语句混杂在一起前后跳来跳去，那简直就没有办法看下去了，这种代码就可称之为 *“意大利面条式代码”*。

实际上这也是使用流程图来表达算法逻辑本来就可能存在的问题。想象一下，流程图中引出来的分支线理论上可以引向任何地方。如果不受限制地使用，把整张图变成不堪入目的一团乱麻并不困难。

基于改良混乱代码形式的要求，结构化编程这种编程思想就被提出来。这一思想提倡尽可能避免使用goto语句，而是使用替代品——选择结构与循环结构来构成程序，从而把程序逻辑约束在一定的结构中，变得更加可靠易懂。事实上，可以证明，不管多么复杂的goto组织成的逻辑，都有某种办法进行严谨的结构化，因此不存在放弃goto会降低语言表现力的问题。

读完本章之后，你也将看到，基于结构化编程的思路，我们也可以将流程图替换为更严谨的表达形式。

### Section 3-2 分支结构与逻辑表达式

#### 3-2-1 if-else语句

一般地，C++中的if语句有两种表达方式。

> + if *(Expression)* *Statement*
>
> + if *(Expression)* *Statement1* <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else *Statement2*

`if` 后面必须紧跟一个用括号包含的逻辑表达式（例如`(t>105)`），执行到该语句时对其进行运算，如果符合，就会执行紧跟在后面的一条语句（必须用分号结束）；如果不符合，就会执行紧跟着else的另一条语句——如果没有写else语句则略过，什么也不做。

看一下下面这个例子，它简单地检测输入的年份是否是闰年。（年份为4的倍数是闰年，但是如果是100的倍数，则必须也是400的倍数才会是闰年）

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if (cur_year%4==0)
		if (cur_year%100==0)
			if (cur_year%400==0) cout << "Leap year!";
			else cout << "Common year.";
		else cout << "Leap year!";
	else cout << "Common year.";
	return 0；
}
```

这个例子表明 if...else... 是可以多层嵌套的。事实上，这个嵌套遵循每个else和上面最近的尚未配对的if配对的原则。

在比较复杂的情况不建议这样书写，可以考虑下面这样让结构更清晰。并且只有这样写才能够支持你在一个分支内执行多条语句。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;

	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				cout << "Look, " ;
				cout << "it's a leap year!";
			} else{
				cout << "Just common year.";
			}
		} else {
			cout << "Look, " ;
			cout << "it's a leap year!";
		}
	} else {
		cout << "Just common year.";
	}
	return 0；
}
```

> 建议：尽量使用{}形式的表达，只在极其简单并且显然的情形不使用它们。

#### 3-2-2 布尔量

现在我们来解析一下if语句当中那个关键的判断式的写法。

用关系运算符将两个表达式连接起来的式子，称关系表达式。

基本的关系运算符包括：

+ 相等： ==
+ 不等： !=
+ 小于： <
+ 大于： >
+ 小于等于： <=
+ 大于等于： >=

> 之所以使用`==`来表示相等，是因为在C++中，`=`符号表示赋值。这是新手常常混淆的关键点。（相应地，由于在PASCAL中规定赋值符号要写成`:=`，于是等于号就不必双写了；不过大部分语言采取C++赋值方式）
>
> `!=` 符号在不同语言中可能形式不同。（常见的其他形式包括：`<>` `~=` ）

关系表达式的运算结果是 **布尔型变量(boolean)** 。该变量只有两种取值： **真(true)** 或 **假(false)** 。在C++中，有基本变量类型`bool`。下面用bool变量改写上面的示例。

```
...
int main(){
	int cur_year;      // current year
	bool flag = false; // a boolean variable

	cin >> cur_year;
	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				flag = true;
			}
		} else {
			flag = true;
		}
	}

	if (flag) {         // "if (flag)" acts the same as "if (flag==true)".
		cout << "Look, it's a leap year!";
	} else {            // meaning 'flag' equals 'false'.
		cout << "Just common year.";
	}

	return 0；
}
```
可以看到流程清晰了很多，并且变得更加可靠。

可以用逻辑运算符将关系表达式或逻辑量连接起来，构成逻辑表达式。

C++中基本的逻辑运算符包括 **与(&&)**， **或(||)**， **非(!)**。

&& 是一个双目运算符，必须两侧变量均为true，运算结果才为true，否则是false。

|| 与前者相反，只需要两侧有一个true，结果即为true；两侧均为false结果才会是false。

! 是单目运算，对其后的逻辑取反，true变为false，false变为true。

运算优先级：! > && > ||, 并且&&和||自身按从左到右顺序。

用这些来改写的一种方法如下所示。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if ( !(cur_year%4==0) || (cur_year%100==0 && cur_year%400!=0)){
		cout << "Leap year!";
	} else {
		cout << "Common year.";
	}
	return 0；
}
```

> 非常特殊，C语言里没有bool变量，C语言使用0表示false，1表示true。事实上，各种语言的编码中，bool量的编码也是这种形式。
>
> C++继承了这种做法。事实上，static_cast\<bool>(int(0))=false，而任何非0整数都会被类型转换为false。这正是C++会让许多新手掉入陷阱的地方。看下面这段代码。
>
> ```
> 	int a = 0;
> 	if (a=0){
> 		...
> 	} else {
> 		...
> 	}
> ```
> 让我们来解释一下这段代码是如何有可能把人逼疯的。
>
> 在这里，不幸地，可能是少打了一个`=` 符号，逻辑表达式部分变成了一个赋值语句——更不幸的是，C++允许这种事发生。注意到，C++中，赋值语句会把结果变量作为表达式的值返回，因此`a=0` 这个式子是有值的，除非发生赋值失败这种基本不可能事件，`a=0` 这个式子的值是0——注意，根据隐式类型转换规则，它将会被解释为false（或者按照经典的C规则相当于false），于是一些本不该发生的事就这样发生了。要在事后发现这个隐蔽的bug有时就没有现在分析这样容易了。
>
> 有一种说法认为因此我们要尽量写`0==a`这种形式作为替代，这是毫无意义的，因为实践情况往往比这要复杂。如果两边都是可修改量该怎么办呢？所以还是采用常规的做法较为有意义，保持风格的协调也是很有必要的。
>
> 值得欣慰的是，多数当代编译器会对尝试在此处写赋值语句提出 **警告(warning)**（但不是一个编译错误(error)），这就减少了悲剧的发生。同时这也提醒你，最好不要尝试用不显眼的做法来让你的意图有可能被误解，不要滥用语言的特性。

有了分支结构，我们就不必用跳转来让代码在不同的分支上选择了。

### Section 3-3 数组与循环

//TODO



[pic_310_01]: img/pic_310_01.png
