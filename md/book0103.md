## Chapter 3 结构化编程

开始在程序中书写一些结构。

### Section 3-1 用goto模拟流程图

上一章我们学习了一些基本的语句写法。包括如何简单地定义一个变量，进行四则运算，把运算结果赋值给另一个变量以及输入和输出。距离一个功能相对完善的程序还有欠缺。

考虑一下我们常见的流程图的结构，不难发现我们还缺少一种起控制流程走向作用的语句。如果不能控制程序的走向，我们就只能按照书写的顺序执行每一条语句代表的指令，这可实现不了任何稍微复杂一点的功能。

因此，最早出现的控制语句就是单纯地起到 **跳转(jump)** 作用的语句，称为goto语句。

单独的goto语句通常不能起到控制作用，必须要配合可以进行判断的功能，这通常是if语句的作用。

我们来看下面这幅流程图是如何用goto语句转换为C++语言的。

![流程图演示][pic_310_01]

```
...
int main(){
	int t = 0;
	int k = 0;

T_OVER_105_NO:
	t = t + k;
	if (t>105) goto T_OVER_105_YES;
	else goto T_OVER_105_NO;

T_OVER_105_YES:
	cout << k;

	return 0;
}
```

C++允许我们不加预先声明地使用一个标记。基本上，标记仅仅只是标记而已。当你使用goto语句来指向一个标记，实际执行到此处时就会跳转到标记处，从标记处继续执行指令。实际上，CPU使用的汇编指令就是这样工作的。

>  `if ... ... else ...` 语句是一个分支结构，允许你根据一个逻辑表达式是否成立来进行分支选择。稍后我们会进一步展开对这个语句的详细解释。
>
>事实上，在goto风格中，if-else语句只需要进行简单的跳转的选择。

看起来我们似乎不错地把这个流程图实现了。不过，恐怕你也注意到，和流程图相比，代码写成这样恐怕不够美观易读。由于代码是在线性的一维上展开，这种跳转形式就必须要非常仔细地阅读跳转过程才能理解，并且可能要写很多goto来把不同的。倘若多个goto语句混杂在一起前后跳来跳去，那简直就没有办法看下去了，这种代码就可称之为 *“意大利面条式代码”*。

实际上这也是使用流程图来表达算法逻辑本来就可能存在的问题。想象一下，流程图中引出来的分支线理论上可以引向任何地方。如果不受限制地使用，把整张图变成不堪入目的一团乱麻并不困难。

基于改良混乱代码形式的要求，结构化编程这种编程思想就被提出来。这一思想提倡尽可能避免使用goto语句，而是使用替代品——选择结构与循环结构来构成程序，从而把程序逻辑约束在一定的结构中，变得更加可靠易懂。事实上，可以证明，不管多么复杂的goto组织成的逻辑，都有某种办法进行严谨的结构化，因此不存在放弃goto会降低语言表现力的问题。

读完本章之后，你也将看到，基于结构化编程的思路，我们也可以将流程图替换为更严谨的表达形式。

### Section 3-2 分支结构与逻辑表达式

#### 3-2-1 if-else语句

一般地，C++中的if语句有两种表达方式。

> + if *(Expression)* *Statement*
>
> + if *(Expression)* *Statement1* <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else *Statement2*

`if` 后面必须紧跟一个用括号包含的逻辑表达式（例如`(t>105)`），执行到该语句时对其进行运算，如果符合，就会执行紧跟在后面的一条语句（必须用分号结束）；如果不符合，就会执行紧跟着else的另一条语句——如果没有写else语句则略过，什么也不做。

看一下下面这个例子，它简单地检测输入的年份是否是闰年。（年份为4的倍数是闰年，但是如果是100的倍数，则必须也是400的倍数才会是闰年）

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if (cur_year%4==0)
		if (cur_year%100==0)
			if (cur_year%400==0) cout << "Leap year!";
			else cout << "Common year.";
		else cout << "Leap year!";
	else cout << "Common year.";
	return 0；
}
```

这个例子表明 if...else... 是可以多层嵌套的。事实上，这个嵌套遵循每个else和上面最近的尚未配对的if配对的原则。

在比较复杂的情况不建议这样书写，可以考虑下面这样让结构更清晰。并且只有这样写才能够支持你在一个分支内执行多条语句。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;

	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				cout << "Look, " ;
				cout << "it's a leap year!";
			} else{
				cout << "Just common year.";
			}
		} else {
			cout << "Look, " ;
			cout << "it's a leap year!";
		}
	} else {
		cout << "Just common year.";
	}
	return 0；
}
```

> 建议：尽量使用{}形式的表达，只在极其简单并且显然的情形不使用它们。

#### 3-2-2 布尔量

现在我们来解析一下if语句当中那个关键的判断式的写法。

用关系运算符将两个表达式连接起来的式子，称关系表达式。

基本的关系运算符包括：

+ 相等： ==
+ 不等： !=
+ 小于： <
+ 大于： >
+ 小于等于： <=
+ 大于等于： >=

> 之所以使用`==`来表示相等，是因为在C++中，`=`符号表示赋值。这是新手常常混淆的关键点。（相应地，由于在PASCAL中规定赋值符号要写成`:=`，于是等于号就不必双写了；不过大部分语言采取C++赋值方式）
>
> `!=` 符号在不同语言中可能形式不同。（常见的其他形式包括：`<>` `~=` ）

关系表达式的运算结果是 **布尔型变量(boolean)** 。该变量只有两种取值： **真(true)** 或 **假(false)** 。在C++中，有基本变量类型`bool`。下面用bool变量改写上面的示例。

```
...
int main(){
	int cur_year;      // current year
	bool flag = false; // a boolean variable

	cin >> cur_year;
	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				flag = true;
			}
		} else {
			flag = true;
		}
	}

	if (flag) {         // "if (flag)" acts the same as "if (flag==true)".
		cout << "Look, it's a leap year!";
	} else {            // meaning 'flag' equals 'false'.
		cout << "Just common year.";
	}

	return 0；
}
```
可以看到流程清晰了很多，并且变得更加可靠。

可以用逻辑运算符将关系表达式或逻辑量连接起来，构成逻辑表达式。

C++中基本的逻辑运算符包括 **与(&&)**， **或(||)**， **非(!)**。

&& 是一个双目运算符，必须两侧变量均为true，运算结果才为true，否则是false。

|| 与前者相反，只需要两侧有一个true，结果即为true；两侧均为false结果才会是false。

! 是单目运算，对其后的逻辑取反，true变为false，false变为true。

运算优先级：! > && > ||, 并且&&和||自身按从左到右顺序。

用这些来改写的一种方法如下所示。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if ( !(cur_year%4==0) || (cur_year%100==0 && cur_year%400!=0)){
		cout << "Leap year!";
	} else {
		cout << "Common year.";
	}
	return 0；
}
```

> 非常特殊，C语言里没有bool变量，C语言使用0表示false，1表示true。事实上，各种语言的编码中，bool量的编码也是这种形式。
>
> C++继承了这种做法。事实上，static_cast\<bool>(int(0))=false，而任何非0整数都会被类型转换为false。这正是C++会让许多新手掉入陷阱的地方。看下面这段代码。
>
> ```
> 	int a = 0;
> 	if (a=0){
> 		...
> 	} else {
> 		...
> 	}
> ```
> 让我们来解释一下这段代码是如何有可能把人逼疯的。
>
> 在这里，不幸地，可能是少打了一个`=` 符号，逻辑表达式部分变成了一个赋值语句——更不幸的是，C++允许这种事发生。注意到，C++中，赋值语句会把结果变量作为表达式的值返回，因此`a=0` 这个式子是有值的，除非发生赋值失败这种基本不可能事件，`a=0` 这个式子的值是0——注意，根据隐式类型转换规则，它将会被解释为false（或者按照经典的C规则相当于false），于是一些本不该发生的事就这样发生了。要在事后发现这个隐蔽的bug有时就没有现在分析这样容易了。
>
> 有一种说法认为因此我们要尽量写`0==a`这种形式作为替代，这是毫无意义的，因为实践情况往往比这要复杂。如果两边都是可修改量该怎么办呢？所以还是采用常规的做法较为有意义，保持风格的协调也是很有必要的。
>
> 值得欣慰的是，多数当代编译器会对尝试在if判断中写赋值语句的行为提出 **警告(warning)**（但不是一个编译错误(error)），这就减少了悲剧的发生。同时这也提醒你，最好不要尝试用不显眼的做法来让你的意图有可能被误解，不要滥用语言的特性。

有了分支结构，我们就不必用跳转来让代码在不同的分支上选择了。

### Section 3-3 循环结构

在不使用goto跳转的情形下，分支结构只能起到类比往后跳转的作用，想要实现往前跳转需要循环语句。


![流程图演示][pic_310_01]

```
...
int main(){
	int t = 0;
	int k = 0;

T_OVER_105_NO:
	t += k;                      //  "t+=k" just means "t=t+k"
	if (t>105) goto T_OVER_105_YES;
	else goto T_OVER_105_NO;

T_OVER_105_YES:
	cout << k;

	return 0;
}
```

>提示：
>C++支持缩写赋值符号，除了+=以外，也有-=, *=, /=, %= 以及其他大部分双目运算符都可以缩写

下面给出使用C++的do-while循环语句改写的示范。

```
...
int main(){
	int t = 0;
	int k = 0;

	do{
		t += k;
	} while (!(t>105));

	cout << k;

	return 0;
}
```

也可以用while循环改写，while循环 *(当型循环)* 一般更常用。


```
...
int main(){
	int t = 0;
	int k = 0;

	while (!(t>105)) t = t + k;
	// The same as:	
	//	while (!(t>105)){
	//		t=t+k;
	//	}

	cout << k;

	return 0;
}
```

不难通过观察得出结论，while的使用类似于if，其后需要跟随一个用括号包含的逻辑表达式，如果逻辑表达式判断为真，就会继续循环，否则就从循环中跳出。这就是按照一定的逻辑反复循环的方法，避免了滥用goto语句造成的混乱。

> + while *(Expression)* *Statement*
>
> + do {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement1* <br>
> } while *(Expression)*;

<br>
> 注意：while循环与do-while的细致差别。do-while意味着先执行再检查条件——总是至少执行一次。一般while更为常用。

下面看一个更具体的例子。

```
#include <iostream>
using namespace std;
int main(){
	int cur_year;
	
	cin >> cur_year;

	while(cur_year%4!=0 || (cur_year%100==0 && cur_year%400!=0)){
		cur_year += 1; // the same as "cur_year = cur_year + 1;"
	}

	cout << "The nearest leap year is " << cur_year << endl;

	return 0;
}

```

上述循环过程实现了对输入的年份查找最接近的闰年（向后寻找）的功能。

while型循环在实现一些特定但是又非常常用的结构时显得比较繁琐，因此绝大多数语言还提供了for循环（计数循环）来支持你把语句写得更清晰。

>一个典型的PASCAL的for循环
>
>```
>int s = 0;
>for i:=1 to 100 do
>	begin
>		s := s+i;
>	end;
>writeln('s = 1+2+3+...+100 = ', s);
>```
>PASCAL的计数循环要求循环变量（简单循环变量常采取i, j, k这样的惯例命名）必须严格每次增加一位，在上述代码段中，i从1逐个变化到100，每次都要执行循环体内的操作。

在C/C++和其他大部分现代语言中，for循环可以写的更灵活，甚至取代while循环（尽管并不建议）。

```
/*标准的C语言for循环*/
int i, s=0;
for (i=1; i<=100; ++i){     // "++i" equals "i+=1".
	s += i;
}
```
```
//C++引入了更灵活的做法
int s=0;
for (int i=1; i<=100; ++i){ // i 将只在这个for循环内部有效
	s += i;
}
```

>C++ for循环
> 
>for ( *for-init-statement*  *condition;*  *expression* ) {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement* <br>
> }
>
>其中
>
+ for-init-statement 是一个以分号结束的初始化语句
+ condition 是一个返回布尔类型的表达式
+ expression 是一个更新操作表达式

注意，基于C++的语法非常宽容的特点，有许多巧妙的技法可以让你的for语句变得更加的精炼和有其他各种形式美（同时不可避免地让新手更加迷惑），但是我们这里不准备在有限的篇幅内讨论这些细节问题。基本上，你最应该掌握的内容是这样的：

>上述for循环的等价形式：
>
>{<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *for-init-statement*<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( *condition* ) {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement* <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *expression* ;<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
>}

也就是说for是对常见的循环方式做了书写上的简化，本质上是一样的。

>##### 较古老编译器（含VC6.0） 的独有缺陷
>
>在C语言中，循环变量必须在循环开始前声明。但是VC6.0为代表的一些编译器在支持C++的新表达方式时有一些问题。
>
>在VC6.0中`for (int i=0;...){...}` 与 `int i; for (i=0; ...){...}` 事实上却是一样的。也就是说，变量i出for范围后依然存在。这非常具有迷惑性。
>
>对于，VC6.0使用者，大约有两种解决方案——一种是使用C语言的原本形式，避免一个不该存在的语法错误；或者，尽快更换到一个没有20年那么久历史的新编译环境下。


>###### 自增与自减符号
>
> C/C++语言提供了一种极其方便的方法来把一个变量自己增加1或者减少1，这就是 *自增(++)* 运算符和 *自减(--)* 运算符。
>
> 在for循环的最后一个部分，既有使用++i的写法，也有使用i++的写法，多数时候在这里这不紧要。
>
> ++分为前置与后置两种，实质上是并不一样的运算符。前置++基本上等同`(i=i+1)`这样的形式，会把变量自增1，然后返回结果；但是后置++会暂时保存变量的当前情况，在把变量自增1之后，会把变量原本的值作为表达式的值，可视作`(tmp=i, i=i+1, tmp)`这一段语句。
>
> 由上可以发现，后置++实际上比前置多一步临时保存的操作——理论上性能存在差距。当然，在现代编译器上，编译优化一般能去掉这种差距。但是考虑一下C++还允许你定制对自定义类型的运算符行为，这也是不一定的事。我们建议，在多数情况下，优先考虑前置++，即使真的需要得到表达式返回值，后置++的出现也很容易降低代码的可读性。
>
> 你必须有节制地使用这几个运算符。C++语句的一个基本原则是，一条语句内一个量最多只应该改变一次。C++不规定某个表达式内各个部分的运算顺序，只要最后它们能按照规定的优先级匹配起来就行。
>
> 对上面这段话用一个例子做一个简单解释。对于一个表达式a*b+c*d，先乘法后加法是可以确定的，但是a*b与c*d哪一个在先并不是确定的。事实上，即使编译器试图把它按规定的顺序译成代码，CPU也很可能根据它们没有依赖关系这一点进行乱序执行。如果你试图把当中的a和c都替换成`i++`（从而变成`(i++)*b+(i++)*d`），无法保证其结果，完全依靠编译器自行采取解释，这将是一个 ***未定义行为(undefined behavior)*** 。进一步的，如果你写出`++i = i++`这种东西，也不能保证赋值符号左边和右边哪一个先计算。



### Section 3-4 数组

考虑一下我们之前给出的一些程序，它们的共同点都是只涉及比较简单的操作，只有很少量的数据要处理。但是，有了循环结构后，我们显然可以处理比较大量的一些数据了。可以看这样一个例子。

```
#include <iostream>
using namespace std;
int main(){
	int x;
	int minnum = INT_MAX; // INT_MAX代表int最大取值，定义在<cstdlib>中
	int s=0;
	for (int i=0; i<100; ++i){
		cin >> x;
		if (x<minnum) minnum = x;
		s += x;
	}
	cout << "Min: " << min << endl;
	cout << "Sum: " << s << endl;
	return 0;
}
```

上面这个简单的例子给出了如何在一段连续的较大规模读入后计算其中数字的最值与和的简单方案。但是，容易想到，如果我们要处理的问题复杂一些——比如要求把输入的无序数字按照顺序重新输出，这样就会遇到困难。

很容易想到一种数学上对应的形式——变量下标。如果有一系列未知量是基本一致、紧密联系的，我们可以使用统一的字母来表述而使用下标来标记不同的量。对应到程序设计语言中这就是数组的想法。

C/C++内置了 **数组(array)** 类型来提供简单的存储一批变量集合的功能。事实上，绝大部分语言都提供数组类型，但是一般而言，这些语言各自提供的类似类型都有很不相同的特性——其中又以C/C++的数组最具有迷惑性，因为C/C++对数组有一些最大化编程自由度而导致严重的含义混乱。（毋宁说，C的数组根本不能称为一个一般的类型）

```
...
int main(){
	int a[100], c[100];
	for (int i=0; i<100; ++i){
		cin >> a[i] >> c[i];
	}
	int s=0;
	for (int i=0; i<100; ++i){
		s += a[i]*c[i];
	}
	cout << s;
	return 0;
}
```

从上面这个简单程序不难看出C++数组的一般声明步骤——只需要在一般的变量声明基础上增加一个`[]`符号来表示这是一个数组就可以了。一般来讲，我们也不可以直接输入或输出数组，也不会直接操作整个数组，而是通过下标引用的形式来对数组中的 **元素(element)** 逐个操作。

在C/C++中，`TYPE VAR[n]`表示定义了一个含有n个元素，名称是VAR，每个元素的变量类型都是TYPE的数组，按下标引用它们分别是`VAR[0]`, `VAR[1]`, `VAR[2]`, ..., `VAR[n-1]`。请注意，下标必须从0开始（你可以把这视作一个规定），而实际上VAR[n]这个变量是超出范围而不存在的。


>访问数组变量时可能出现使用的下标越界的情形，这一般是一个严重错误。如上所见，你使用的下标索引可以是基于变量计算出来的表达式，所以大部分不能在编译时检查出这种错误。那么，程序运行时，可以检查这种错误吗？
>
>多数语言会保障下标的安全性，也就是说每次引用数组元素都要确认下标的合法性（通过比较运算），这就隐含了一些额外的运算。但是C/C++奉行 ***zero-overhead原则（零额外开销）*** ，你必须自己严格确保下标的安全性，否则如果发生了下标越界，将会产生未定义行为，这时程序多半很可能还能继续运行——然而之后发生什么奇怪的致命错误都有可能，而且很难检查其原因。这要求你空前地谨慎，时刻搞清楚自己在写什么。

除此之外，C++也支持你定义维度更高的数组，这是通过定义“数组的数组来实现的”。例如，`int d[m][n];`这条语句声明了一个二维数组d。需要注意的是，它可以被看做由m个长度由为n的数组接成的数组的数组，经常，它可以被用作表示一个m行n列的矩阵，这个矩阵中每一行是一个子数组。

### Section 3-5 灵活跳转

#### 3-5-1 switch-case 分支

考虑这样一个问题：对于班上若干个人，已知他们的具体成绩（百分制），希望统计ABCDF各等级的具体人数。一个可能的写法是这样的：

```
int n, ca, cb, cc, cd, cf;
ca = cb = cc = cd = cf = 0;
...
for (int i=0; i<n; ++i){
	if (grade[i]>=90){
		++ca;
	} else if (grade[i]>=80){
		++cb;
	} else if (grade[i]>=70){
		++cc;
	} else if (grade[i]>=60){
		++cd;
	} else {
		++cf;
	}
}
```

上面这种写法是一种相对良好的写法，通过if-else连锁来枚举情形，这启示我们在嵌套if语句时尽量在else分支中展开。不过，仅此而已，这样写显得还是有些繁琐。

switch-case语句提供了多重分支选择的功能。实际上大部分语言都有类似功能。然而，不幸的是C/C++的switch-case仍然有一些鹤立鸡群的诡异特性不得不提。


```
int n, ca, cb, cc, cd, cf;
ca = cb = cc = cd = cf = 0;
...
for (int i=0; i<n; ++i){
	switch (grade[i]/10) {
	case 10:
	case 9:
		++ca;
		break;
	case 8:
		++cb;
		break;
	case 7:
		++cc;
	break;
	case 6:
		++cd;
		break;
	default:
		++cf;
	}
}
```

语法如下：

```
switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选
    case constant-expression  :
       statement(s);
       break; // 可选
	...
    default : // 可选..
       statement(s);
}
```

其中，switch 后紧随一个括号包括的表达式，该表达式必须返回一个“可枚举” 的值，通常即整数类型以及可强制转换为整数类型的类型。根据这个表达式返回的值跳转到对应case标签上，如果没有匹配值，则跳转到default，如果未写default，则会直接结束（一般来讲，推荐即使如此也要写明一个空的default来显式地指出这一点）。

事实上，case与default标签都可以看作为switch特化的goto标签。在C++中，默认跳转到对应标签后会顺延执行完swtich内接下来的所有语句，因此，多数情形下，我们还要使用一个break语句来强制跳出switch。

>由于C/C++ switch语句的这些无聊特性，下面这段代码甚至有可能编译通过。
>
>```
>switch (caption_int){
>case 1:
>	int i;  //定义i
>	break;
>case 2:
>	++i;    //i被认为已有定义，一般这是一个warning而非error
>	if (i<0){
>		case 3: cout << "crazy!";
>	}
>	break;
>}
>```
>而下面的另一份代码则不能
>
>```
>switch (caption_int){
>case 1:
>	int i = caption_int;
>	cout << i+1;
>case 2:
>	int i = 0;  //重复定义!
>	...
>}
>```
>
>因此，你要遵循大致基本的守则包括：
>
>+ 尽可能只在switch内部进行简单的操作；
>+ case必须在最外层；
>+ 所有分支都严格使用break退出；
>+ 考虑用大括号限制，如下所示。
>
>```
>swtich (x) {
>    case 1: {
>			...
>            break; //也可以写在大括号外
>        }
>    case 2: {
>			...
>            break;
>        }
>    }
>```

#### 3-5-2 break/continue 跳出

纵观以上介绍的各种语句结构，它们都是对goto语句进行了限制和包装。这样并不减少我们可表达的逻辑的丰富程度，反而能让我们更清晰地表达程序的运行结构（并且摆脱构思标记名的无聊活动）。总而概括之，程序的基本结构只需要顺序结构、分支结构、循环结构就可以完成。

> 可以证明这三大基本结构足以完全表达任何形式的goto逻辑。基本思路较为简单，此处略去。

此外我们也可以总结到，尽管杂乱地在代码段中跳转来跳转去是不明智的，但是有节制地控制跳转的方向可以避免混乱。总的来讲，跳转的基本原则包括：

+ 只在循环等情形时采用回跳，尽量只向后跳转；

+ 避免从一个结构外侧直接跳转进其内部分支中，只进行平级跳转或者跳出结构；

+ 尽量统一跳转点，减少分散的跳转标记，理清逻辑关系。


基于上述几点，在循环语句中还提供break语句和continue语句来进行跳转，它们不是标准的结构化编程组件，但是非常有效，并能进一步加强代码的清晰度。

现在请看这样一个问题：在一个数组中存放着一系列整数，要求你找出下标最小的整数。

如果没有break语句，就只能使用标记法了。

```
...
int t = -1;
for (int i=0; (t<0 && i<n); ++i) {
	if (a[i]<0) t=i;
}
cout << a[t];
```

上面这个做法还取了一点巧。有时你可能无法从现成的标记里简单判断循环应该中途结束，这种时候你还不得不额外定义一个布尔型变量来辅助。这种方法很大妨碍了逻辑的简洁性。

再考虑这样一段：

```
int x;
do{
	cin >> x;
	cout << x;
	if (x%2==0){
		...
	}
}while (x!=0);
```

这段`if (x%2==0)`基本才是while语句的唯一重点，但是由于if的存在层次变得很破败。

现在我们用break和continue来改写。

```
...
int t = -1;
for (int i=0; i<n; ++i) {
	if (a[i]<0){
		t=i;
		break;  //跳出循环
	}
}
cout << a[t];
```

```
int x;
do{
	cin >> x;
	cout << x;
	if (x%2!=0){
		continue; //跳出本次循环
	}
	...
}while (x!=0);
```

break与continue都能实现立即从循环中跳出的功能，略有不同的是，break会直接跳到循环外，而continue只是结束本次循环，然后进入下一次循环，值得注意的是这时for语句就表现得和while语句不同，依然会执行循环变量的更新。

无论何处使用break/continue，都会跳出最接近的一层循环——如果你正处于多重循环的嵌套当中，只能对当前的最内层循环生效。如果你尝试在循环外使用break/continue，这则是一个编译错误。另外要提出的警告是，break还和switch语句有交叉，所以你不能在switch当中跳转出包裹switch的循环。

#### 3-5-3 bubble-sort 冒泡

把一个无序的数组按照指定的规则重排为有序的状态，这就是一个基本的问题——排序。

考虑到顺序可以是根据情况变化而自定义的形态，因此，我们只能假定元素可以进行比较运算而未必能假定可以像整数那样按位比较。

下面给出简单排序中一个表现良好的算法示例—— ***冒泡排序(bubble sort)***

```
int s[MAXN];
int n;
...
bool flag;
int t;
for (int i=n-1; i>0; --i){
	flag = true;
	for (int j=0; j<i; ++j){
		if (s[j]>s[j+1]){
			flag = false;
			t = s[j];
			s[j] = s[j+1];
			s[j+1] = t;
		}
	}
	if (flag) break;
}
```

[pic_310_01]: img/pic_310_01.png
