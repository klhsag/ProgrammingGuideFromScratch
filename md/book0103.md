## Chapter 3 结构化编程

开始在程序中书写一些结构。

### Section 3-1 用goto模拟流程图

上一章我们学习了一些基本的语句写法。包括如何简单地定义一个变量，进行四则运算，把运算结果赋值给另一个变量以及输入和输出。距离一个功能相对完善的程序还有欠缺。

考虑一下我们常见的流程图的结构，不难发现我们还缺少一种起控制流程走向作用的语句。如果不能控制程序的走向，我们就只能按照书写的顺序执行每一条语句代表的指令，这可实现不了任何稍微复杂一点的功能。

因此，最早出现的控制语句就是单纯地起到 **跳转(jump)** 作用的语句，称为goto语句。

单独的goto语句通常不能起到控制作用，必须要配合可以进行判断的功能，这通常是if语句的作用。

我们来看下面这幅流程图是如何用goto语句转换为C++语言的。

![流程图演示][pic_310_01]

```
...
int main(){
	int t = 0;
	int k = 0;

T_OVER_105_NO:
	t = t + k;
	if (t>105) goto T_OVER_105_YES;
	else goto T_OVER_105_NO;

T_OVER_105_YES:
	cout << k;

	return 0;
}
```

C++允许我们不加预先声明地使用一个标记。基本上，标记仅仅只是标记而已。当你使用goto语句来指向一个标记，实际执行到此处时就会跳转到标记处，从标记处继续执行指令。实际上，CPU使用的汇编指令就是这样工作的。

>  `if ... ... else ...` 语句是一个分支结构，允许你根据一个逻辑表达式是否成立来进行分支选择。稍后我们会进一步展开对这个语句的详细解释。
>
>事实上，在goto风格中，if-else语句只需要进行简单的跳转的选择。

看起来我们似乎不错地把这个流程图实现了。不过，恐怕你也注意到，和流程图相比，代码写成这样恐怕不够美观易读。由于代码是在线性的一维上展开，这种跳转形式就必须要非常仔细地阅读跳转过程才能理解，并且可能要写很多goto来把不同的。倘若多个goto语句混杂在一起前后跳来跳去，那简直就没有办法看下去了，这种代码就可称之为 *“意大利面条式代码”*。

实际上这也是使用流程图来表达算法逻辑本来就可能存在的问题。想象一下，流程图中引出来的分支线理论上可以引向任何地方。如果不受限制地使用，把整张图变成不堪入目的一团乱麻并不困难。

基于改良混乱代码形式的要求，结构化编程这种编程思想就被提出来。这一思想提倡尽可能避免使用goto语句，而是使用替代品——选择结构与循环结构来构成程序，从而把程序逻辑约束在一定的结构中，变得更加可靠易懂。事实上，可以证明，不管多么复杂的goto组织成的逻辑，都有某种办法进行严谨的结构化，因此不存在放弃goto会降低语言表现力的问题。

读完本章之后，你也将看到，基于结构化编程的思路，我们也可以将流程图替换为更严谨的表达形式。

### Section 3-2 分支结构与逻辑表达式

#### 3-2-1 if-else语句

一般地，C++中的if语句有两种表达方式。

> + if *(Expression)* *Statement*
>
> + if *(Expression)* *Statement1* <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else *Statement2*

`if` 后面必须紧跟一个用括号包含的逻辑表达式（例如`(t>105)`），执行到该语句时对其进行运算，如果符合，就会执行紧跟在后面的一条语句（必须用分号结束）；如果不符合，就会执行紧跟着else的另一条语句——如果没有写else语句则略过，什么也不做。

看一下下面这个例子，它简单地检测输入的年份是否是闰年。（年份为4的倍数是闰年，但是如果是100的倍数，则必须也是400的倍数才会是闰年）

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if (cur_year%4==0)
		if (cur_year%100==0)
			if (cur_year%400==0) cout << "Leap year!";
			else cout << "Common year.";
		else cout << "Leap year!";
	else cout << "Common year.";
	return 0；
}
```

这个例子表明 if...else... 是可以多层嵌套的。事实上，这个嵌套遵循每个else和上面最近的尚未配对的if配对的原则。

在比较复杂的情况不建议这样书写，可以考虑下面这样让结构更清晰。并且只有这样写才能够支持你在一个分支内执行多条语句。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;

	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				cout << "Look, " ;
				cout << "it's a leap year!";
			} else{
				cout << "Just common year.";
			}
		} else {
			cout << "Look, " ;
			cout << "it's a leap year!";
		}
	} else {
		cout << "Just common year.";
	}
	return 0；
}
```

> 建议：尽量使用{}形式的表达，只在极其简单并且显然的情形不使用它们。

#### 3-2-2 布尔量

现在我们来解析一下if语句当中那个关键的判断式的写法。

用关系运算符将两个表达式连接起来的式子，称关系表达式。

基本的关系运算符包括：

+ 相等： ==
+ 不等： !=
+ 小于： <
+ 大于： >
+ 小于等于： <=
+ 大于等于： >=

> 之所以使用`==`来表示相等，是因为在C++中，`=`符号表示赋值。这是新手常常混淆的关键点。（相应地，由于在PASCAL中规定赋值符号要写成`:=`，于是等于号就不必双写了；不过大部分语言采取C++赋值方式）
>
> `!=` 符号在不同语言中可能形式不同。（常见的其他形式包括：`<>` `~=` ）

关系表达式的运算结果是 **布尔型变量(boolean)** 。该变量只有两种取值： **真(true)** 或 **假(false)** 。在C++中，有基本变量类型`bool`。下面用bool变量改写上面的示例。

```
...
int main(){
	int cur_year;      // current year
	bool flag = false; // a boolean variable

	cin >> cur_year;
	if (cur_year%4==0) {
		if (cur_year%100==0) {
			if (cur_year%400==0){
				flag = true;
			}
		} else {
			flag = true;
		}
	}

	if (flag) {         // "if (flag)" acts the same as "if (flag==true)".
		cout << "Look, it's a leap year!";
	} else {            // meaning 'flag' equals 'false'.
		cout << "Just common year.";
	}

	return 0；
}
```
可以看到流程清晰了很多，并且变得更加可靠。

可以用逻辑运算符将关系表达式或逻辑量连接起来，构成逻辑表达式。

C++中基本的逻辑运算符包括 **与(&&)**， **或(||)**， **非(!)**。

&& 是一个双目运算符，必须两侧变量均为true，运算结果才为true，否则是false。

|| 与前者相反，只需要两侧有一个true，结果即为true；两侧均为false结果才会是false。

! 是单目运算，对其后的逻辑取反，true变为false，false变为true。

运算优先级：! > && > ||, 并且&&和||自身按从左到右顺序。

用这些来改写的一种方法如下所示。

```
...
int main(){
	int cur_year; // current year
	cin >> cur_year;
	if ( !(cur_year%4==0) || (cur_year%100==0 && cur_year%400!=0)){
		cout << "Leap year!";
	} else {
		cout << "Common year.";
	}
	return 0；
}
```

> 非常特殊，C语言里没有bool变量，C语言使用0表示false，1表示true。事实上，各种语言的编码中，bool量的编码也是这种形式。
>
> C++继承了这种做法。事实上，static_cast\<bool>(int(0))=false，而任何非0整数都会被类型转换为false。这正是C++会让许多新手掉入陷阱的地方。看下面这段代码。
>
> ```
> 	int a = 0;
> 	if (a=0){
> 		...
> 	} else {
> 		...
> 	}
> ```
> 让我们来解释一下这段代码是如何有可能把人逼疯的。
>
> 在这里，不幸地，可能是少打了一个`=` 符号，逻辑表达式部分变成了一个赋值语句——更不幸的是，C++允许这种事发生。注意到，C++中，赋值语句会把结果变量作为表达式的值返回，因此`a=0` 这个式子是有值的，除非发生赋值失败这种基本不可能事件，`a=0` 这个式子的值是0——注意，根据隐式类型转换规则，它将会被解释为false（或者按照经典的C规则相当于false），于是一些本不该发生的事就这样发生了。要在事后发现这个隐蔽的bug有时就没有现在分析这样容易了。
>
> 有一种说法认为因此我们要尽量写`0==a`这种形式作为替代，这是毫无意义的，因为实践情况往往比这要复杂。如果两边都是可修改量该怎么办呢？所以还是采用常规的做法较为有意义，保持风格的协调也是很有必要的。
>
> 值得欣慰的是，多数当代编译器会对尝试在if判断中写赋值语句的行为提出 **警告(warning)**（但不是一个编译错误(error)），这就减少了悲剧的发生。同时这也提醒你，最好不要尝试用不显眼的做法来让你的意图有可能被误解，不要滥用语言的特性。

有了分支结构，我们就不必用跳转来让代码在不同的分支上选择了。

### Section 3-3 循环结构

在不使用goto跳转的情形下，分支结构只能起到类比往后跳转的作用，想要实现往前跳转需要循环语句。


![流程图演示][pic_310_01]

```
...
int main(){
	int t = 0;
	int k = 0;

T_OVER_105_NO:
	t += k;                      //  "t+=k" just means "t=t+k"
	if (t>105) goto T_OVER_105_YES;
	else goto T_OVER_105_NO;

T_OVER_105_YES:
	cout << k;

	return 0;
}
```

>提示：
>C++支持缩写赋值符号，除了+=以外，也有-=, *=, /=, %= 以及其他大部分双目运算符都可以缩写

下面给出使用C++的do-while循环语句改写的示范。

```
...
int main(){
	int t = 0;
	int k = 0;

	do{
		t += k;
	} while (!(t>105));

	cout << k;

	return 0;
}
```

也可以用while循环改写，while循环 *(当型循环)* 一般更常用。


```
...
int main(){
	int t = 0;
	int k = 0;

	while (!(t>105)) t = t + k;
	// The same as:	
	//	while (!(t>105)){
	//		t=t+k;
	//	}

	cout << k;

	return 0;
}
```

不难通过观察得出结论，while的使用类似于if，其后需要跟随一个用括号包含的逻辑表达式，如果逻辑表达式判断为真，就会继续循环，否则就从循环中跳出。这就是按照一定的逻辑反复循环的方法，避免了滥用goto语句造成的混乱。

> + while *(Expression)* *Statement*
>
> + do {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement1* <br>
> } while *(Expression)*;

<br>
> 注意：while循环与do-while的细致差别。do-while意味着先执行再检查条件——总是至少执行一次。一般while更为常用。

下面看一个更具体的例子。

```
#include <iostream>
using namespace std;
int main(){
	int cur_year;
	
	cin >> cur_year;

	while(cur_year%4!=0 || (cur_year%100==0 && cur_year%400!=0)){
		cur_year += 1; // the same as "cur_year = cur_year + 1;"
	}

	cout << "The nearest leap year is " << cur_year << endl;

	return 0;
}

```

上述循环过程实现了对输入的年份查找最接近的闰年（向后寻找）的功能。

while型循环在实现一些特定但是又非常常用的结构时显得比较繁琐，因此绝大多数语言还提供了for循环（计数循环）来支持你把语句写得更清晰。

>一个典型的PASCAL的for循环
>
>```
>int s = 0;
>for i:=1 to 100 do
>	begin
>		s := s+i;
>	end;
>writeln('s = 1+2+3+...+100 = ', s);
>```
>PASCAL的计数循环要求循环变量（简单循环变量常采取i, j, k这样的惯例命名）必须严格每次增加一位，在上述代码段中，i从1逐个变化到100，每次都要执行循环体内的操作。

在C/C++和其他大部分现代语言中，for循环可以写的更灵活，甚至取代while循环（尽管并不建议）。

```
/*标准的C语言for循环*/
int i, s=0;
for (i=1; i<=100; ++i){     // "++i" equals "i+=1".
	s += i;
}
```
```
//C++引入了更灵活的做法
int s=0;
for (int i=1; i<=100; ++i){ // i 将只在这个for循环内部有效
	s += i;
}
```

>C++ for循环
> 
>for ( *for-init-statement*  *condition;*  *expression* ) {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement* <br>
> }
>
>其中
>
+ for-init-statement 是一个以分号结束的初始化语句
+ condition 是一个返回布尔类型的表达式
+ expression 是一个更新操作表达式

注意，基于C++的语法非常宽容的特点，有许多巧妙的技法可以让你的for语句变得更加的精炼和有其他各种形式美（同时不可避免地让新手更加迷惑），但是我们这里不准备在有限的篇幅内讨论这些细节问题。基本上，你最应该掌握的内容是这样的：

>上述for循环的等价形式：
>
>{<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *for-init-statement*<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( *condition* ) {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Statement* <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *expression* ;<br>
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
>}

也就是说for是对常见的循环方式做了书写上的简化，本质上是一样的。

>###### 自增与自减符号
>
> C/C++语言提供了一种极其方便的方法来把一个变量自己增加1或者减少1，这就是 *自增(++)* 运算符和 *自减(--)* 运算符。
>
> 在for循环的最后一个部分，既有使用++i的写法，也有使用i++的写法，多数时候在这里这不紧要。
>
> ++分为前置与后置两种，实质上是并不一样的运算符。前置++基本上等同`(i=i+1)`这样的形式，会把变量自增1，然后返回结果；但是后置++会暂时保存变量的当前情况，在把变量自增1之后，会把变量原本的值作为表达式的值，可视作`(tmp=i, i=i+1, tmp)`这一段语句。
>
> 由上可以发现，后置++实际上比前置多一步临时保存的操作——理论上性能存在差距。当然，在现代编译器上，编译优化一般能去掉这种差距。但是考虑一下C++还允许你定制对自定义类型的运算符行为，这也是不一定的事。我们建议，在多数情况下，优先考虑前置++，即使真的需要得到表达式返回值，后置++的出现也很容易降低代码的可读性。
>
> 你必须有节制地使用这几个运算符。C++语句的一个基本原则是，一条语句内一个量最多只应该改变一次。C++不规定某个表达式内各个部分的运算顺序，只要最后它们能按照规定的优先级匹配起来就行。
>
> 对上面这段话用一个例子做一个简单解释。对于一个表达式a*b+c*d，先乘法后加法是可以确定的，但是a*b与c*d哪一个在先并不是确定的。事实上，即使编译器试图把它按规定的顺序译成代码，CPU也很可能根据它们没有依赖关系这一点进行乱序执行。如果你试图把当中的a和c都替换成`i++`（从而变成`(i++)*b+(i++)*d`），无法保证其结果，完全依靠编译器自行采取解释，这将是一个 ***未定义行为(undefined behavior)*** 。进一步的，如果你写出`++i = i++`这种东西，也不能保证赋值符号左边和右边哪一个先计算。

### Section 3-4 数组




[pic_310_01]: img/pic_310_01.png